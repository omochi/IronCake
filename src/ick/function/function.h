// This file was GENERATED by command:
//     pump.py function.h.pump
// DO NOT EDIT BY HAND!!!

#pragma once

#include "../base/memory.h"
#include "../base/property.h"

#include "base_function_holder.h"
#include "native_function_holder.h"

namespace ick {
	template <typename F> class Function;

	template <typename R>
	class Function<R(*)()>{
	public:
		typedef R (*FunctionType)();
		typedef Function<FunctionType> ThisType;
	private:
		BaseFunctionHolder<FunctionType> * holder_;
		bool holder_release_;
	public:
		BaseFunctionHolder<FunctionType> * holder() const { return holder_; }

		Function():
		holder_(NULL),
		holder_release_(false)
		{
		}
		// ネイティブ関数からの暗黙変換
		// explicit
		Function(FunctionType native_function):
		holder_(ICK_NEW(NativeFunctionHolder<FunctionType>,
						native_function)),
		holder_release_(true)
		{
		}
		Function(BaseFunctionHolder<FunctionType> * holder,
				 bool holder_release):
		holder_(holder),
		holder_release_(holder_release)
		{
		}
		Function(const ThisType & copy):
		holder_(NULL),
		holder_release_(false)
		{
			*this = copy;
		}
		virtual ~Function(){
			PropertyClear(holder_, holder_release_);
		}
		ThisType & operator = (const ThisType & copy){
			PropertySet(holder_, holder_release_, copy.holder_->Clone(), true);
			return * this;
		}
		R operator() () {
			return (*holder_)();
		}
	};


	template <typename R, typename A1>
	class Function<R(*)(A1)>{
	public:
		typedef R (*FunctionType)(A1);
		typedef Function<FunctionType> ThisType;
	private:
		BaseFunctionHolder<FunctionType> * holder_;
		bool holder_release_;
	public:
		BaseFunctionHolder<FunctionType> * holder() const { return holder_; }

		Function():
		holder_(NULL),
		holder_release_(false)
		{
		}
		// ネイティブ関数からの暗黙変換
		// explicit
		Function(FunctionType native_function):
		holder_(ICK_NEW(NativeFunctionHolder<FunctionType>,
						native_function)),
		holder_release_(true)
		{
		}
		Function(BaseFunctionHolder<FunctionType> * holder,
				 bool holder_release):
		holder_(holder),
		holder_release_(holder_release)
		{
		}
		Function(const ThisType & copy):
		holder_(NULL),
		holder_release_(false)
		{
			*this = copy;
		}
		virtual ~Function(){
			PropertyClear(holder_, holder_release_);
		}
		ThisType & operator = (const ThisType & copy){
			PropertySet(holder_, holder_release_, copy.holder_->Clone(), true);
			return * this;
		}
		R operator() (A1 a1) {
			return (*holder_)(a1);
		}
	};


	template <typename R, typename A1, typename A2>
	class Function<R(*)(A1, A2)>{
	public:
		typedef R (*FunctionType)(A1, A2);
		typedef Function<FunctionType> ThisType;
	private:
		BaseFunctionHolder<FunctionType> * holder_;
		bool holder_release_;
	public:
		BaseFunctionHolder<FunctionType> * holder() const { return holder_; }

		Function():
		holder_(NULL),
		holder_release_(false)
		{
		}
		// ネイティブ関数からの暗黙変換
		// explicit
		Function(FunctionType native_function):
		holder_(ICK_NEW(NativeFunctionHolder<FunctionType>,
						native_function)),
		holder_release_(true)
		{
		}
		Function(BaseFunctionHolder<FunctionType> * holder,
				 bool holder_release):
		holder_(holder),
		holder_release_(holder_release)
		{
		}
		Function(const ThisType & copy):
		holder_(NULL),
		holder_release_(false)
		{
			*this = copy;
		}
		virtual ~Function(){
			PropertyClear(holder_, holder_release_);
		}
		ThisType & operator = (const ThisType & copy){
			PropertySet(holder_, holder_release_, copy.holder_->Clone(), true);
			return * this;
		}
		R operator() (A1 a1, A2 a2) {
			return (*holder_)(a1, a2);
		}
	};


	template <typename R, typename A1, typename A2, typename A3>
	class Function<R(*)(A1, A2, A3)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3);
		typedef Function<FunctionType> ThisType;
	private:
		BaseFunctionHolder<FunctionType> * holder_;
		bool holder_release_;
	public:
		BaseFunctionHolder<FunctionType> * holder() const { return holder_; }

		Function():
		holder_(NULL),
		holder_release_(false)
		{
		}
		// ネイティブ関数からの暗黙変換
		// explicit
		Function(FunctionType native_function):
		holder_(ICK_NEW(NativeFunctionHolder<FunctionType>,
						native_function)),
		holder_release_(true)
		{
		}
		Function(BaseFunctionHolder<FunctionType> * holder,
				 bool holder_release):
		holder_(holder),
		holder_release_(holder_release)
		{
		}
		Function(const ThisType & copy):
		holder_(NULL),
		holder_release_(false)
		{
			*this = copy;
		}
		virtual ~Function(){
			PropertyClear(holder_, holder_release_);
		}
		ThisType & operator = (const ThisType & copy){
			PropertySet(holder_, holder_release_, copy.holder_->Clone(), true);
			return * this;
		}
		R operator() (A1 a1, A2 a2, A3 a3) {
			return (*holder_)(a1, a2, a3);
		}
	};


	template <typename R, typename A1, typename A2, typename A3, typename A4>
	class Function<R(*)(A1, A2, A3, A4)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4);
		typedef Function<FunctionType> ThisType;
	private:
		BaseFunctionHolder<FunctionType> * holder_;
		bool holder_release_;
	public:
		BaseFunctionHolder<FunctionType> * holder() const { return holder_; }

		Function():
		holder_(NULL),
		holder_release_(false)
		{
		}
		// ネイティブ関数からの暗黙変換
		// explicit
		Function(FunctionType native_function):
		holder_(ICK_NEW(NativeFunctionHolder<FunctionType>,
						native_function)),
		holder_release_(true)
		{
		}
		Function(BaseFunctionHolder<FunctionType> * holder,
				 bool holder_release):
		holder_(holder),
		holder_release_(holder_release)
		{
		}
		Function(const ThisType & copy):
		holder_(NULL),
		holder_release_(false)
		{
			*this = copy;
		}
		virtual ~Function(){
			PropertyClear(holder_, holder_release_);
		}
		ThisType & operator = (const ThisType & copy){
			PropertySet(holder_, holder_release_, copy.holder_->Clone(), true);
			return * this;
		}
		R operator() (A1 a1, A2 a2, A3 a3, A4 a4) {
			return (*holder_)(a1, a2, a3, a4);
		}
	};


 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5>
	class Function<R(*)(A1, A2, A3, A4, A5)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5);
		typedef Function<FunctionType> ThisType;
	private:
		BaseFunctionHolder<FunctionType> * holder_;
		bool holder_release_;
	public:
		BaseFunctionHolder<FunctionType> * holder() const { return holder_; }

		Function():
		holder_(NULL),
		holder_release_(false)
		{
		}
		// ネイティブ関数からの暗黙変換
		// explicit
		Function(FunctionType native_function):
		holder_(ICK_NEW(NativeFunctionHolder<FunctionType>,
						native_function)),
		holder_release_(true)
		{
		}
		Function(BaseFunctionHolder<FunctionType> * holder,
				 bool holder_release):
		holder_(holder),
		holder_release_(holder_release)
		{
		}
		Function(const ThisType & copy):
		holder_(NULL),
		holder_release_(false)
		{
			*this = copy;
		}
		virtual ~Function(){
			PropertyClear(holder_, holder_release_);
		}
		ThisType & operator = (const ThisType & copy){
			PropertySet(holder_, holder_release_, copy.holder_->Clone(), true);
			return * this;
		}
		R operator() (A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) {
			return (*holder_)(a1, a2, a3, a4, a5);
		}
	};


 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5, typename A6>
	class Function<R(*)(A1, A2, A3, A4, A5, A6)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5, A6);
		typedef Function<FunctionType> ThisType;
	private:
		BaseFunctionHolder<FunctionType> * holder_;
		bool holder_release_;
	public:
		BaseFunctionHolder<FunctionType> * holder() const { return holder_; }

		Function():
		holder_(NULL),
		holder_release_(false)
		{
		}
		// ネイティブ関数からの暗黙変換
		// explicit
		Function(FunctionType native_function):
		holder_(ICK_NEW(NativeFunctionHolder<FunctionType>,
						native_function)),
		holder_release_(true)
		{
		}
		Function(BaseFunctionHolder<FunctionType> * holder,
				 bool holder_release):
		holder_(holder),
		holder_release_(holder_release)
		{
		}
		Function(const ThisType & copy):
		holder_(NULL),
		holder_release_(false)
		{
			*this = copy;
		}
		virtual ~Function(){
			PropertyClear(holder_, holder_release_);
		}
		ThisType & operator = (const ThisType & copy){
			PropertySet(holder_, holder_release_, copy.holder_->Clone(), true);
			return * this;
		}
		R operator() (A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) {
			return (*holder_)(a1, a2, a3, a4, a5, a6);
		}
	};


 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5, typename A6, typename A7>
	class Function<R(*)(A1, A2, A3, A4, A5, A6, A7)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5, A6, A7);
		typedef Function<FunctionType> ThisType;
	private:
		BaseFunctionHolder<FunctionType> * holder_;
		bool holder_release_;
	public:
		BaseFunctionHolder<FunctionType> * holder() const { return holder_; }

		Function():
		holder_(NULL),
		holder_release_(false)
		{
		}
		// ネイティブ関数からの暗黙変換
		// explicit
		Function(FunctionType native_function):
		holder_(ICK_NEW(NativeFunctionHolder<FunctionType>,
						native_function)),
		holder_release_(true)
		{
		}
		Function(BaseFunctionHolder<FunctionType> * holder,
				 bool holder_release):
		holder_(holder),
		holder_release_(holder_release)
		{
		}
		Function(const ThisType & copy):
		holder_(NULL),
		holder_release_(false)
		{
			*this = copy;
		}
		virtual ~Function(){
			PropertyClear(holder_, holder_release_);
		}
		ThisType & operator = (const ThisType & copy){
			PropertySet(holder_, holder_release_, copy.holder_->Clone(), true);
			return * this;
		}
		R operator() (A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) {
			return (*holder_)(a1, a2, a3, a4, a5, a6, a7);
		}
	};


 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5, typename A6, typename A7, typename A8>
	class Function<R(*)(A1, A2, A3, A4, A5, A6, A7, A8)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5, A6, A7, A8);
		typedef Function<FunctionType> ThisType;
	private:
		BaseFunctionHolder<FunctionType> * holder_;
		bool holder_release_;
	public:
		BaseFunctionHolder<FunctionType> * holder() const { return holder_; }

		Function():
		holder_(NULL),
		holder_release_(false)
		{
		}
		// ネイティブ関数からの暗黙変換
		// explicit
		Function(FunctionType native_function):
		holder_(ICK_NEW(NativeFunctionHolder<FunctionType>,
						native_function)),
		holder_release_(true)
		{
		}
		Function(BaseFunctionHolder<FunctionType> * holder,
				 bool holder_release):
		holder_(holder),
		holder_release_(holder_release)
		{
		}
		Function(const ThisType & copy):
		holder_(NULL),
		holder_release_(false)
		{
			*this = copy;
		}
		virtual ~Function(){
			PropertyClear(holder_, holder_release_);
		}
		ThisType & operator = (const ThisType & copy){
			PropertySet(holder_, holder_release_, copy.holder_->Clone(), true);
			return * this;
		}
		R operator() (A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) {
			return (*holder_)(a1, a2, a3, a4, a5, a6, a7, a8);
		}
	};



}

