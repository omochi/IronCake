// This file was GENERATED by command:
//     pump.py function.h.pump
// DO NOT EDIT BY HAND!!!

#pragma once

#include "../base/memory.h"

#include "functor_holder.h"

namespace ick {
	template <typename FP> class Function;
 template <typename F,
     typename FP> Function<FP> FunctionMake(const F & functor);


	template <typename R>
	class Function<R(*)()>{
	public:
		typedef R (*FunctionType)();
		typedef Function<FunctionType> ThisType;
	private:
		ThisType & operator = (const ThisType & copy);

		BaseFunctorHolder<FunctionType> * holder_;
	public:
		BaseFunctorHolder<FunctionType> * holder() const { return holder_; }

		//暗黙
		Function(FunctionType native_function){
   holder_ = ICK_NEW(FunctorHolder<FunctionType ICK_COMMA FunctionType>,
       native_function);
		}
		explicit Function(const BaseFunctorHolder<FunctionType> & holder){
			holder_ = holder.Clone();
		}
		Function(const ThisType & copy){
			holder_ = copy.holder_->Clone();
		}
		virtual ~Function(){
			ICK_DELETE(holder_);
		}
		R operator() () {
			return (*holder_)();
		}
	};


	template <typename R, typename A1>
	class Function<R(*)(A1)>{
	public:
		typedef R (*FunctionType)(A1);
		typedef Function<FunctionType> ThisType;
	private:
		ThisType & operator = (const ThisType & copy);

		BaseFunctorHolder<FunctionType> * holder_;
	public:
		BaseFunctorHolder<FunctionType> * holder() const { return holder_; }

		//暗黙
		Function(FunctionType native_function){
   holder_ = ICK_NEW(FunctorHolder<FunctionType ICK_COMMA FunctionType>,
       native_function);
		}
		explicit Function(const BaseFunctorHolder<FunctionType> & holder){
			holder_ = holder.Clone();
		}
		Function(const ThisType & copy){
			holder_ = copy.holder_->Clone();
		}
		virtual ~Function(){
			ICK_DELETE(holder_);
		}
		R operator() (A1 a1) {
			return (*holder_)(a1);
		}
	};


	template <typename R, typename A1, typename A2>
	class Function<R(*)(A1, A2)>{
	public:
		typedef R (*FunctionType)(A1, A2);
		typedef Function<FunctionType> ThisType;
	private:
		ThisType & operator = (const ThisType & copy);

		BaseFunctorHolder<FunctionType> * holder_;
	public:
		BaseFunctorHolder<FunctionType> * holder() const { return holder_; }

		//暗黙
		Function(FunctionType native_function){
   holder_ = ICK_NEW(FunctorHolder<FunctionType ICK_COMMA FunctionType>,
       native_function);
		}
		explicit Function(const BaseFunctorHolder<FunctionType> & holder){
			holder_ = holder.Clone();
		}
		Function(const ThisType & copy){
			holder_ = copy.holder_->Clone();
		}
		virtual ~Function(){
			ICK_DELETE(holder_);
		}
		R operator() (A1 a1, A2 a2) {
			return (*holder_)(a1, a2);
		}
	};


	template <typename R, typename A1, typename A2, typename A3>
	class Function<R(*)(A1, A2, A3)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3);
		typedef Function<FunctionType> ThisType;
	private:
		ThisType & operator = (const ThisType & copy);

		BaseFunctorHolder<FunctionType> * holder_;
	public:
		BaseFunctorHolder<FunctionType> * holder() const { return holder_; }

		//暗黙
		Function(FunctionType native_function){
   holder_ = ICK_NEW(FunctorHolder<FunctionType ICK_COMMA FunctionType>,
       native_function);
		}
		explicit Function(const BaseFunctorHolder<FunctionType> & holder){
			holder_ = holder.Clone();
		}
		Function(const ThisType & copy){
			holder_ = copy.holder_->Clone();
		}
		virtual ~Function(){
			ICK_DELETE(holder_);
		}
		R operator() (A1 a1, A2 a2, A3 a3) {
			return (*holder_)(a1, a2, a3);
		}
	};


	template <typename R, typename A1, typename A2, typename A3, typename A4>
	class Function<R(*)(A1, A2, A3, A4)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4);
		typedef Function<FunctionType> ThisType;
	private:
		ThisType & operator = (const ThisType & copy);

		BaseFunctorHolder<FunctionType> * holder_;
	public:
		BaseFunctorHolder<FunctionType> * holder() const { return holder_; }

		//暗黙
		Function(FunctionType native_function){
   holder_ = ICK_NEW(FunctorHolder<FunctionType ICK_COMMA FunctionType>,
       native_function);
		}
		explicit Function(const BaseFunctorHolder<FunctionType> & holder){
			holder_ = holder.Clone();
		}
		Function(const ThisType & copy){
			holder_ = copy.holder_->Clone();
		}
		virtual ~Function(){
			ICK_DELETE(holder_);
		}
		R operator() (A1 a1, A2 a2, A3 a3, A4 a4) {
			return (*holder_)(a1, a2, a3, a4);
		}
	};


 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5>
	class Function<R(*)(A1, A2, A3, A4, A5)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5);
		typedef Function<FunctionType> ThisType;
	private:
		ThisType & operator = (const ThisType & copy);

		BaseFunctorHolder<FunctionType> * holder_;
	public:
		BaseFunctorHolder<FunctionType> * holder() const { return holder_; }

		//暗黙
		Function(FunctionType native_function){
   holder_ = ICK_NEW(FunctorHolder<FunctionType ICK_COMMA FunctionType>,
       native_function);
		}
		explicit Function(const BaseFunctorHolder<FunctionType> & holder){
			holder_ = holder.Clone();
		}
		Function(const ThisType & copy){
			holder_ = copy.holder_->Clone();
		}
		virtual ~Function(){
			ICK_DELETE(holder_);
		}
		R operator() (A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) {
			return (*holder_)(a1, a2, a3, a4, a5);
		}
	};


 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5, typename A6>
	class Function<R(*)(A1, A2, A3, A4, A5, A6)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5, A6);
		typedef Function<FunctionType> ThisType;
	private:
		ThisType & operator = (const ThisType & copy);

		BaseFunctorHolder<FunctionType> * holder_;
	public:
		BaseFunctorHolder<FunctionType> * holder() const { return holder_; }

		//暗黙
		Function(FunctionType native_function){
   holder_ = ICK_NEW(FunctorHolder<FunctionType ICK_COMMA FunctionType>,
       native_function);
		}
		explicit Function(const BaseFunctorHolder<FunctionType> & holder){
			holder_ = holder.Clone();
		}
		Function(const ThisType & copy){
			holder_ = copy.holder_->Clone();
		}
		virtual ~Function(){
			ICK_DELETE(holder_);
		}
		R operator() (A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) {
			return (*holder_)(a1, a2, a3, a4, a5, a6);
		}
	};


 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5, typename A6, typename A7>
	class Function<R(*)(A1, A2, A3, A4, A5, A6, A7)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5, A6, A7);
		typedef Function<FunctionType> ThisType;
	private:
		ThisType & operator = (const ThisType & copy);

		BaseFunctorHolder<FunctionType> * holder_;
	public:
		BaseFunctorHolder<FunctionType> * holder() const { return holder_; }

		//暗黙
		Function(FunctionType native_function){
   holder_ = ICK_NEW(FunctorHolder<FunctionType ICK_COMMA FunctionType>,
       native_function);
		}
		explicit Function(const BaseFunctorHolder<FunctionType> & holder){
			holder_ = holder.Clone();
		}
		Function(const ThisType & copy){
			holder_ = copy.holder_->Clone();
		}
		virtual ~Function(){
			ICK_DELETE(holder_);
		}
		R operator() (A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) {
			return (*holder_)(a1, a2, a3, a4, a5, a6, a7);
		}
	};


 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5, typename A6, typename A7, typename A8>
	class Function<R(*)(A1, A2, A3, A4, A5, A6, A7, A8)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5, A6, A7, A8);
		typedef Function<FunctionType> ThisType;
	private:
		ThisType & operator = (const ThisType & copy);

		BaseFunctorHolder<FunctionType> * holder_;
	public:
		BaseFunctorHolder<FunctionType> * holder() const { return holder_; }

		//暗黙
		Function(FunctionType native_function){
   holder_ = ICK_NEW(FunctorHolder<FunctionType ICK_COMMA FunctionType>,
       native_function);
		}
		explicit Function(const BaseFunctorHolder<FunctionType> & holder){
			holder_ = holder.Clone();
		}
		Function(const ThisType & copy){
			holder_ = copy.holder_->Clone();
		}
		virtual ~Function(){
			ICK_DELETE(holder_);
		}
		R operator() (A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) {
			return (*holder_)(a1, a2, a3, a4, a5, a6, a7, a8);
		}
	};


	template <typename F, typename FP>
	Function<FP> FunctionMake(const F & functor){
		return Function<FP>(FunctorHolder<F, FP>(functor));
	}

}

