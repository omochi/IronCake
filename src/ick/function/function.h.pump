#pragma once

#include "../base/memory.h"
#include "../base/property.h"

#include "base_function_holder.h"
#include "native_function_holder.h"

namespace ick {
	template <typename F> class Function;
	$var an_max = 8
	$range an 0..an_max
	$for an [[
	$range ai 1..an

	template <typename R$for ai [[, typename A$ai]]>
	class Function<R(*)($for ai , [[A$ai]])>{
	public:
		typedef R (*FunctionType)($for ai , [[A$ai]]);
		typedef Function<FunctionType> ThisType;
	private:
		BaseFunctionHolder<FunctionType> * holder_;
		bool holder_release_;
	public:
		BaseFunctionHolder<FunctionType> * holder() const { return holder_; }

		Function():
		holder_(NULL),
		holder_release_(false)
		{
		}
		// ネイティブ関数からの暗黙変換
		// explicit
		Function(FunctionType native_function):
		holder_(ICK_NEW(NativeFunctionHolder<FunctionType>,
						native_function)),
		holder_release_(true)
		{
		}
		Function(BaseFunctionHolder<FunctionType> * holder,
				 bool holder_release):
		holder_(holder),
		holder_release_(holder_release)
		{
		}
		Function(const ThisType & copy):
		holder_(NULL),
		holder_release_(false)
		{
			*this = copy;
		}
		virtual ~Function(){
			PropertyClear(holder_, holder_release_);
		}
		ThisType & operator = (const ThisType & copy){
			PropertySet(holder_, holder_release_, copy.holder_->Clone(), true);
			return * this;
		}
		R operator() ($for ai , [[A$ai a$ai]]) { 
			return (*holder_)($for ai , [[a$ai]]); 
		}
	};

	]]
	

}

