#pragma once

#include "../base/memory.h"
#include "../base/property.h"

#include "functor_holder.h"

namespace ick {
	template <typename FP> class Function;
	template <typename F, typename FP> Function<FP> FunctionMake(const F & functor);

	$var an_max = 8
	$range an 0..an_max
	$for an [[
	$range ai 1..an

	template <typename R$for ai [[, typename A$ai]]>
	class Function<R(*)($for ai , [[A$ai]])>{
	public:
		typedef R (*FunctionType)($for ai , [[A$ai]]);
		typedef Function<FunctionType> ThisType;
	private:
		BaseFunctorHolder<FunctionType> * holder_;
	public:
		BaseFunctorHolder<FunctionType> * holder() const { return holder_; }

		Function():
		holder_(NULL){
		}
		//暗黙変換
		Function(FunctionType native_function):
		holder_(
			ICK_NEW(FunctorHolder<FunctionType ICK_COMMA FunctionType>, 
				native_function)){
		}
		explicit Function(const BaseFunctorHolder<FunctionType> & holder):
		holder_(holder.Clone()){
		}
		Function(const ThisType & copy):
		holder_(NULL){
			*this = copy;
		}
		virtual ~Function(){
			PropertyClear(holder_);
		}
		ThisType & operator = (const ThisType & copy){
			PropertySet(holder_, copy.holder_->Clone());
			return * this;
		}
		R operator() ($for ai , [[A$ai a$ai]]) { 
			return (*holder_)($for ai , [[a$ai]]); 
		}
	};

	]]
	
	template <typename F, typename FP>
	Function<FP> FunctionMake(const F & functor){
		return Function<FP>(FunctorHolder<F, FP>(functor));
	}

}

