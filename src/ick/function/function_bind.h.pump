#pragma once

#include "../base/memory.h"

#include "function_bind_decl.h"
#include "functor_holder.h"
#include "function.h"

namespace ick {
	template <typename FP, int N> class FunctionBinder;

	$var an_max = 8
	$range an 0..an_max $$ args num
	$for an [[
	$range ai 1..an
	$range bn 1..an $$ bind num
	$for bn [[
	$range bi 1..bn
	$var can = an - bn $$ call args num
	$range cai bn+1..an

	template <typename R$for ai [[, typename A$ai]]>
	class FunctionBinder<R(*)($for ai , [[A$ai]]),$bn>{
	public:
		typedef R (*FunctionType)($for ai , [[A$ai]]);
		typedef FunctionBinder<FunctionType,$bn> ThisType;
	private:
		Function<R(*)($for ai , [[A$ai]])> function_;
		$for bi [[A$bi a$bi[[]]_; ]]

	public:
		FunctionBinder(const Function<R(*)($for ai , [[A$ai]])> & function, $for bi , [[A$bi a$bi]]):
		function_(function),
		$for bi , [[a$bi[[]]_(a$bi)]]
		
		{
		}
		virtual ~FunctionBinder(){}

		virtual R operator() ($for cai , [[A$cai a$cai]]) {
			return function_($for bi , [[a$bi[[]]_]] $if (bn * can) > 0 [[, ]] $for cai , [[a$cai]]);
		}
	};
	
	template <typename R$for ai [[, typename A$ai]]>
	Function<R(*)($for cai , [[A$cai]])> 
	FunctionBind$bn(Function<R(*)($for ai , [[A$ai]])> function $for bi [[, A$bi a$bi]]){
		return FunctionMake<FunctionBinder<R(*)($for ai , [[A$ai]]),$bn>,R(*)($for cai , [[A$cai]])>(
			FunctionBinder<R(*)($for ai , [[A$ai]]),$bn>(function $for bi [[, a$bi]])
		);
	}

	template <typename R$for ai [[, typename A$ai]]>
	Function<R(*)($for cai , [[A$cai]])> 
	FunctionBind$bn(R (*function)($for ai , [[A$ai]]) $for bi [[, A$bi a$bi]]){
		return FunctionBind$bn(Function<R(*)($for ai , [[A$ai]])>(function)
			$for bi [[, a$bi]]);
	}

	]] $$ bind num
	]] $$ args num

}
