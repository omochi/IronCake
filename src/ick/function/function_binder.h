// This file was GENERATED by command:
//     pump.py function_binder.h.pump
// DO NOT EDIT BY HAND!!!

#pragma once

#include "../base/memory.h"

#include "base_function_holder.h"
#include "function.h"

namespace ick {
	template <typename F> class BaseFunctionHolder;
	template <typename F, int N> class FunctionBinder;

	// 引数1個の関数に、1個の引数をbindして、
	// 引数0個の関数にする。
	template <typename R, typename A1>
	class FunctionBinder<R(*)(A1), 1> :
		public BaseFunctionHolder<R(*)()>{
	public:
		typedef R (*FunctionType)(A1);
		typedef R (*CallFunctionType)();
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef FunctionBinder<FunctionType, 1> ThisType;
	private:
		BaseFunctionHolder<FunctionType> * holder_;
		A1 a1_;
	public:
		FunctionBinder(const BaseFunctionHolder<FunctionType> * holder, A1 a1):
		holder_(holder->Clone()),
		a1_(a1)
		{
		}
		virtual ~FunctionBinder(){
			ICK_DELETE(holder_);
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, holder_, a1_);
		}
		virtual R operator() () {
			return (*holder_)(a1_);
		}
	};


	// 引数2個の関数に、1個の引数をbindして、
	// 引数1個の関数にする。
	template <typename R, typename A1, typename A2>
	class FunctionBinder<R(*)(A1, A2), 1> :
		public BaseFunctionHolder<R(*)(A2)>{
	public:
		typedef R (*FunctionType)(A1, A2);
		typedef R (*CallFunctionType)(A2);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef FunctionBinder<FunctionType, 1> ThisType;
	private:
		BaseFunctionHolder<FunctionType> * holder_;
		A1 a1_;
	public:
		FunctionBinder(const BaseFunctionHolder<FunctionType> * holder, A1 a1):
		holder_(holder->Clone()),
		a1_(a1)
		{
		}
		virtual ~FunctionBinder(){
			ICK_DELETE(holder_);
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, holder_, a1_);
		}
		virtual R operator() (A2 a2) {
			return (*holder_)(a1_, a2);
		}
	};


	// 引数2個の関数に、2個の引数をbindして、
	// 引数0個の関数にする。
	template <typename R, typename A1, typename A2>
	class FunctionBinder<R(*)(A1, A2), 2> :
		public BaseFunctionHolder<R(*)()>{
	public:
		typedef R (*FunctionType)(A1, A2);
		typedef R (*CallFunctionType)();
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef FunctionBinder<FunctionType, 2> ThisType;
	private:
		BaseFunctionHolder<FunctionType> * holder_;
		A1 a1_; A2 a2_;
	public:
		FunctionBinder(const BaseFunctionHolder<FunctionType> * holder, A1 a1, A2 a2):
		holder_(holder->Clone()),
		a1_(a1), a2_(a2)
		{
		}
		virtual ~FunctionBinder(){
			ICK_DELETE(holder_);
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, holder_, a1_, a2_);
		}
		virtual R operator() () {
			return (*holder_)(a1_, a2_);
		}
	};


	// 引数3個の関数に、1個の引数をbindして、
	// 引数2個の関数にする。
	template <typename R, typename A1, typename A2, typename A3>
	class FunctionBinder<R(*)(A1, A2, A3), 1> :
		public BaseFunctionHolder<R(*)(A2, A3)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3);
		typedef R (*CallFunctionType)(A2, A3);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef FunctionBinder<FunctionType, 1> ThisType;
	private:
		BaseFunctionHolder<FunctionType> * holder_;
		A1 a1_;
	public:
		FunctionBinder(const BaseFunctionHolder<FunctionType> * holder, A1 a1):
		holder_(holder->Clone()),
		a1_(a1)
		{
		}
		virtual ~FunctionBinder(){
			ICK_DELETE(holder_);
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, holder_, a1_);
		}
		virtual R operator() (A2 a2, A3 a3) {
			return (*holder_)(a1_, a2, a3);
		}
	};


	// 引数3個の関数に、2個の引数をbindして、
	// 引数1個の関数にする。
	template <typename R, typename A1, typename A2, typename A3>
	class FunctionBinder<R(*)(A1, A2, A3), 2> :
		public BaseFunctionHolder<R(*)(A3)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3);
		typedef R (*CallFunctionType)(A3);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef FunctionBinder<FunctionType, 2> ThisType;
	private:
		BaseFunctionHolder<FunctionType> * holder_;
		A1 a1_; A2 a2_;
	public:
		FunctionBinder(const BaseFunctionHolder<FunctionType> * holder, A1 a1, A2 a2):
		holder_(holder->Clone()),
		a1_(a1), a2_(a2)
		{
		}
		virtual ~FunctionBinder(){
			ICK_DELETE(holder_);
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, holder_, a1_, a2_);
		}
		virtual R operator() (A3 a3) {
			return (*holder_)(a1_, a2_, a3);
		}
	};


	// 引数3個の関数に、3個の引数をbindして、
	// 引数0個の関数にする。
	template <typename R, typename A1, typename A2, typename A3>
	class FunctionBinder<R(*)(A1, A2, A3), 3> :
		public BaseFunctionHolder<R(*)()>{
	public:
		typedef R (*FunctionType)(A1, A2, A3);
		typedef R (*CallFunctionType)();
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef FunctionBinder<FunctionType, 3> ThisType;
	private:
		BaseFunctionHolder<FunctionType> * holder_;
		A1 a1_; A2 a2_; A3 a3_;
	public:
  FunctionBinder(const BaseFunctionHolder<FunctionType> * holder, A1 a1, A2 a2,
      A3 a3):
		holder_(holder->Clone()),
		a1_(a1), a2_(a2), a3_(a3)
		{
		}
		virtual ~FunctionBinder(){
			ICK_DELETE(holder_);
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, holder_, a1_, a2_, a3_);
		}
		virtual R operator() () {
			return (*holder_)(a1_, a2_, a3_);
		}
	};


	// 引数4個の関数に、1個の引数をbindして、
	// 引数3個の関数にする。
	template <typename R, typename A1, typename A2, typename A3, typename A4>
	class FunctionBinder<R(*)(A1, A2, A3, A4), 1> :
		public BaseFunctionHolder<R(*)(A2, A3, A4)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4);
		typedef R (*CallFunctionType)(A2, A3, A4);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef FunctionBinder<FunctionType, 1> ThisType;
	private:
		BaseFunctionHolder<FunctionType> * holder_;
		A1 a1_;
	public:
		FunctionBinder(const BaseFunctionHolder<FunctionType> * holder, A1 a1):
		holder_(holder->Clone()),
		a1_(a1)
		{
		}
		virtual ~FunctionBinder(){
			ICK_DELETE(holder_);
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, holder_, a1_);
		}
		virtual R operator() (A2 a2, A3 a3, A4 a4) {
			return (*holder_)(a1_, a2, a3, a4);
		}
	};


	// 引数4個の関数に、2個の引数をbindして、
	// 引数2個の関数にする。
	template <typename R, typename A1, typename A2, typename A3, typename A4>
	class FunctionBinder<R(*)(A1, A2, A3, A4), 2> :
		public BaseFunctionHolder<R(*)(A3, A4)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4);
		typedef R (*CallFunctionType)(A3, A4);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef FunctionBinder<FunctionType, 2> ThisType;
	private:
		BaseFunctionHolder<FunctionType> * holder_;
		A1 a1_; A2 a2_;
	public:
		FunctionBinder(const BaseFunctionHolder<FunctionType> * holder, A1 a1, A2 a2):
		holder_(holder->Clone()),
		a1_(a1), a2_(a2)
		{
		}
		virtual ~FunctionBinder(){
			ICK_DELETE(holder_);
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, holder_, a1_, a2_);
		}
		virtual R operator() (A3 a3, A4 a4) {
			return (*holder_)(a1_, a2_, a3, a4);
		}
	};


	// 引数4個の関数に、3個の引数をbindして、
	// 引数1個の関数にする。
	template <typename R, typename A1, typename A2, typename A3, typename A4>
	class FunctionBinder<R(*)(A1, A2, A3, A4), 3> :
		public BaseFunctionHolder<R(*)(A4)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4);
		typedef R (*CallFunctionType)(A4);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef FunctionBinder<FunctionType, 3> ThisType;
	private:
		BaseFunctionHolder<FunctionType> * holder_;
		A1 a1_; A2 a2_; A3 a3_;
	public:
  FunctionBinder(const BaseFunctionHolder<FunctionType> * holder, A1 a1, A2 a2,
      A3 a3):
		holder_(holder->Clone()),
		a1_(a1), a2_(a2), a3_(a3)
		{
		}
		virtual ~FunctionBinder(){
			ICK_DELETE(holder_);
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, holder_, a1_, a2_, a3_);
		}
		virtual R operator() (A4 a4) {
			return (*holder_)(a1_, a2_, a3_, a4);
		}
	};


	// 引数4個の関数に、4個の引数をbindして、
	// 引数0個の関数にする。
	template <typename R, typename A1, typename A2, typename A3, typename A4>
	class FunctionBinder<R(*)(A1, A2, A3, A4), 4> :
		public BaseFunctionHolder<R(*)()>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4);
		typedef R (*CallFunctionType)();
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef FunctionBinder<FunctionType, 4> ThisType;
	private:
		BaseFunctionHolder<FunctionType> * holder_;
		A1 a1_; A2 a2_; A3 a3_; A4 a4_;
	public:
  FunctionBinder(const BaseFunctionHolder<FunctionType> * holder, A1 a1, A2 a2,
      A3 a3, A4 a4):
		holder_(holder->Clone()),
		a1_(a1), a2_(a2), a3_(a3), a4_(a4)
		{
		}
		virtual ~FunctionBinder(){
			ICK_DELETE(holder_);
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, holder_, a1_, a2_, a3_, a4_);
		}
		virtual R operator() () {
			return (*holder_)(a1_, a2_, a3_, a4_);
		}
	};


	// 引数5個の関数に、1個の引数をbindして、
	// 引数4個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5>
	class FunctionBinder<R(*)(A1, A2, A3, A4, A5), 1> :
		public BaseFunctionHolder<R(*)(A2, A3, A4, A5)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5);
		typedef R (*CallFunctionType)(A2, A3, A4, A5);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef FunctionBinder<FunctionType, 1> ThisType;
	private:
		BaseFunctionHolder<FunctionType> * holder_;
		A1 a1_;
	public:
		FunctionBinder(const BaseFunctionHolder<FunctionType> * holder, A1 a1):
		holder_(holder->Clone()),
		a1_(a1)
		{
		}
		virtual ~FunctionBinder(){
			ICK_DELETE(holder_);
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, holder_, a1_);
		}
		virtual R operator() (A2 a2, A3 a3, A4 a4, A5 a5) {
			return (*holder_)(a1_, a2, a3, a4, a5);
		}
	};


	// 引数5個の関数に、2個の引数をbindして、
	// 引数3個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5>
	class FunctionBinder<R(*)(A1, A2, A3, A4, A5), 2> :
		public BaseFunctionHolder<R(*)(A3, A4, A5)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5);
		typedef R (*CallFunctionType)(A3, A4, A5);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef FunctionBinder<FunctionType, 2> ThisType;
	private:
		BaseFunctionHolder<FunctionType> * holder_;
		A1 a1_; A2 a2_;
	public:
		FunctionBinder(const BaseFunctionHolder<FunctionType> * holder, A1 a1, A2 a2):
		holder_(holder->Clone()),
		a1_(a1), a2_(a2)
		{
		}
		virtual ~FunctionBinder(){
			ICK_DELETE(holder_);
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, holder_, a1_, a2_);
		}
		virtual R operator() (A3 a3, A4 a4, A5 a5) {
			return (*holder_)(a1_, a2_, a3, a4, a5);
		}
	};


	// 引数5個の関数に、3個の引数をbindして、
	// 引数2個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5>
	class FunctionBinder<R(*)(A1, A2, A3, A4, A5), 3> :
		public BaseFunctionHolder<R(*)(A4, A5)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5);
		typedef R (*CallFunctionType)(A4, A5);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef FunctionBinder<FunctionType, 3> ThisType;
	private:
		BaseFunctionHolder<FunctionType> * holder_;
		A1 a1_; A2 a2_; A3 a3_;
	public:
  FunctionBinder(const BaseFunctionHolder<FunctionType> * holder, A1 a1, A2 a2,
      A3 a3):
		holder_(holder->Clone()),
		a1_(a1), a2_(a2), a3_(a3)
		{
		}
		virtual ~FunctionBinder(){
			ICK_DELETE(holder_);
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, holder_, a1_, a2_, a3_);
		}
		virtual R operator() (A4 a4, A5 a5) {
			return (*holder_)(a1_, a2_, a3_, a4, a5);
		}
	};


	// 引数5個の関数に、4個の引数をbindして、
	// 引数1個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5>
	class FunctionBinder<R(*)(A1, A2, A3, A4, A5), 4> :
		public BaseFunctionHolder<R(*)(A5)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5);
		typedef R (*CallFunctionType)(A5);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef FunctionBinder<FunctionType, 4> ThisType;
	private:
		BaseFunctionHolder<FunctionType> * holder_;
		A1 a1_; A2 a2_; A3 a3_; A4 a4_;
	public:
  FunctionBinder(const BaseFunctionHolder<FunctionType> * holder, A1 a1, A2 a2,
      A3 a3, A4 a4):
		holder_(holder->Clone()),
		a1_(a1), a2_(a2), a3_(a3), a4_(a4)
		{
		}
		virtual ~FunctionBinder(){
			ICK_DELETE(holder_);
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, holder_, a1_, a2_, a3_, a4_);
		}
		virtual R operator() (A5 a5) {
			return (*holder_)(a1_, a2_, a3_, a4_, a5);
		}
	};


	// 引数5個の関数に、5個の引数をbindして、
	// 引数0個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5>
	class FunctionBinder<R(*)(A1, A2, A3, A4, A5), 5> :
		public BaseFunctionHolder<R(*)()>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5);
		typedef R (*CallFunctionType)();
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef FunctionBinder<FunctionType, 5> ThisType;
	private:
		BaseFunctionHolder<FunctionType> * holder_;
		A1 a1_; A2 a2_; A3 a3_; A4 a4_; A5 a5_;
	public:
  FunctionBinder(const BaseFunctionHolder<FunctionType> * holder, A1 a1, A2 a2,
      A3 a3, A4 a4, A5 a5):
		holder_(holder->Clone()),
		a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5)
		{
		}
		virtual ~FunctionBinder(){
			ICK_DELETE(holder_);
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, holder_, a1_, a2_, a3_, a4_, a5_);
		}
		virtual R operator() () {
			return (*holder_)(a1_, a2_, a3_, a4_, a5_);
		}
	};


	// 引数6個の関数に、1個の引数をbindして、
	// 引数5個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5, typename A6>
	class FunctionBinder<R(*)(A1, A2, A3, A4, A5, A6), 1> :
		public BaseFunctionHolder<R(*)(A2, A3, A4, A5, A6)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5, A6);
		typedef R (*CallFunctionType)(A2, A3, A4, A5, A6);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef FunctionBinder<FunctionType, 1> ThisType;
	private:
		BaseFunctionHolder<FunctionType> * holder_;
		A1 a1_;
	public:
		FunctionBinder(const BaseFunctionHolder<FunctionType> * holder, A1 a1):
		holder_(holder->Clone()),
		a1_(a1)
		{
		}
		virtual ~FunctionBinder(){
			ICK_DELETE(holder_);
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, holder_, a1_);
		}
		virtual R operator() (A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) {
			return (*holder_)(a1_, a2, a3, a4, a5, a6);
		}
	};


	// 引数6個の関数に、2個の引数をbindして、
	// 引数4個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5, typename A6>
	class FunctionBinder<R(*)(A1, A2, A3, A4, A5, A6), 2> :
		public BaseFunctionHolder<R(*)(A3, A4, A5, A6)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5, A6);
		typedef R (*CallFunctionType)(A3, A4, A5, A6);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef FunctionBinder<FunctionType, 2> ThisType;
	private:
		BaseFunctionHolder<FunctionType> * holder_;
		A1 a1_; A2 a2_;
	public:
		FunctionBinder(const BaseFunctionHolder<FunctionType> * holder, A1 a1, A2 a2):
		holder_(holder->Clone()),
		a1_(a1), a2_(a2)
		{
		}
		virtual ~FunctionBinder(){
			ICK_DELETE(holder_);
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, holder_, a1_, a2_);
		}
		virtual R operator() (A3 a3, A4 a4, A5 a5, A6 a6) {
			return (*holder_)(a1_, a2_, a3, a4, a5, a6);
		}
	};


	// 引数6個の関数に、3個の引数をbindして、
	// 引数3個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5, typename A6>
	class FunctionBinder<R(*)(A1, A2, A3, A4, A5, A6), 3> :
		public BaseFunctionHolder<R(*)(A4, A5, A6)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5, A6);
		typedef R (*CallFunctionType)(A4, A5, A6);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef FunctionBinder<FunctionType, 3> ThisType;
	private:
		BaseFunctionHolder<FunctionType> * holder_;
		A1 a1_; A2 a2_; A3 a3_;
	public:
  FunctionBinder(const BaseFunctionHolder<FunctionType> * holder, A1 a1, A2 a2,
      A3 a3):
		holder_(holder->Clone()),
		a1_(a1), a2_(a2), a3_(a3)
		{
		}
		virtual ~FunctionBinder(){
			ICK_DELETE(holder_);
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, holder_, a1_, a2_, a3_);
		}
		virtual R operator() (A4 a4, A5 a5, A6 a6) {
			return (*holder_)(a1_, a2_, a3_, a4, a5, a6);
		}
	};


	// 引数6個の関数に、4個の引数をbindして、
	// 引数2個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5, typename A6>
	class FunctionBinder<R(*)(A1, A2, A3, A4, A5, A6), 4> :
		public BaseFunctionHolder<R(*)(A5, A6)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5, A6);
		typedef R (*CallFunctionType)(A5, A6);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef FunctionBinder<FunctionType, 4> ThisType;
	private:
		BaseFunctionHolder<FunctionType> * holder_;
		A1 a1_; A2 a2_; A3 a3_; A4 a4_;
	public:
  FunctionBinder(const BaseFunctionHolder<FunctionType> * holder, A1 a1, A2 a2,
      A3 a3, A4 a4):
		holder_(holder->Clone()),
		a1_(a1), a2_(a2), a3_(a3), a4_(a4)
		{
		}
		virtual ~FunctionBinder(){
			ICK_DELETE(holder_);
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, holder_, a1_, a2_, a3_, a4_);
		}
		virtual R operator() (A5 a5, A6 a6) {
			return (*holder_)(a1_, a2_, a3_, a4_, a5, a6);
		}
	};


	// 引数6個の関数に、5個の引数をbindして、
	// 引数1個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5, typename A6>
	class FunctionBinder<R(*)(A1, A2, A3, A4, A5, A6), 5> :
		public BaseFunctionHolder<R(*)(A6)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5, A6);
		typedef R (*CallFunctionType)(A6);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef FunctionBinder<FunctionType, 5> ThisType;
	private:
		BaseFunctionHolder<FunctionType> * holder_;
		A1 a1_; A2 a2_; A3 a3_; A4 a4_; A5 a5_;
	public:
  FunctionBinder(const BaseFunctionHolder<FunctionType> * holder, A1 a1, A2 a2,
      A3 a3, A4 a4, A5 a5):
		holder_(holder->Clone()),
		a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5)
		{
		}
		virtual ~FunctionBinder(){
			ICK_DELETE(holder_);
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, holder_, a1_, a2_, a3_, a4_, a5_);
		}
		virtual R operator() (A6 a6) {
			return (*holder_)(a1_, a2_, a3_, a4_, a5_, a6);
		}
	};


	// 引数6個の関数に、6個の引数をbindして、
	// 引数0個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5, typename A6>
	class FunctionBinder<R(*)(A1, A2, A3, A4, A5, A6), 6> :
		public BaseFunctionHolder<R(*)()>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5, A6);
		typedef R (*CallFunctionType)();
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef FunctionBinder<FunctionType, 6> ThisType;
	private:
		BaseFunctionHolder<FunctionType> * holder_;
		A1 a1_; A2 a2_; A3 a3_; A4 a4_; A5 a5_; A6 a6_;
	public:
  FunctionBinder(const BaseFunctionHolder<FunctionType> * holder, A1 a1, A2 a2,
      A3 a3, A4 a4, A5 a5, A6 a6):
		holder_(holder->Clone()),
		a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5), a6_(a6)
		{
		}
		virtual ~FunctionBinder(){
			ICK_DELETE(holder_);
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, holder_, a1_, a2_, a3_, a4_, a5_, a6_);
		}
		virtual R operator() () {
			return (*holder_)(a1_, a2_, a3_, a4_, a5_, a6_);
		}
	};


	// 引数7個の関数に、1個の引数をbindして、
	// 引数6個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5, typename A6, typename A7>
	class FunctionBinder<R(*)(A1, A2, A3, A4, A5, A6, A7), 1> :
		public BaseFunctionHolder<R(*)(A2, A3, A4, A5, A6, A7)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5, A6, A7);
		typedef R (*CallFunctionType)(A2, A3, A4, A5, A6, A7);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef FunctionBinder<FunctionType, 1> ThisType;
	private:
		BaseFunctionHolder<FunctionType> * holder_;
		A1 a1_;
	public:
		FunctionBinder(const BaseFunctionHolder<FunctionType> * holder, A1 a1):
		holder_(holder->Clone()),
		a1_(a1)
		{
		}
		virtual ~FunctionBinder(){
			ICK_DELETE(holder_);
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, holder_, a1_);
		}
		virtual R operator() (A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) {
			return (*holder_)(a1_, a2, a3, a4, a5, a6, a7);
		}
	};


	// 引数7個の関数に、2個の引数をbindして、
	// 引数5個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5, typename A6, typename A7>
	class FunctionBinder<R(*)(A1, A2, A3, A4, A5, A6, A7), 2> :
		public BaseFunctionHolder<R(*)(A3, A4, A5, A6, A7)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5, A6, A7);
		typedef R (*CallFunctionType)(A3, A4, A5, A6, A7);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef FunctionBinder<FunctionType, 2> ThisType;
	private:
		BaseFunctionHolder<FunctionType> * holder_;
		A1 a1_; A2 a2_;
	public:
		FunctionBinder(const BaseFunctionHolder<FunctionType> * holder, A1 a1, A2 a2):
		holder_(holder->Clone()),
		a1_(a1), a2_(a2)
		{
		}
		virtual ~FunctionBinder(){
			ICK_DELETE(holder_);
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, holder_, a1_, a2_);
		}
		virtual R operator() (A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) {
			return (*holder_)(a1_, a2_, a3, a4, a5, a6, a7);
		}
	};


	// 引数7個の関数に、3個の引数をbindして、
	// 引数4個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5, typename A6, typename A7>
	class FunctionBinder<R(*)(A1, A2, A3, A4, A5, A6, A7), 3> :
		public BaseFunctionHolder<R(*)(A4, A5, A6, A7)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5, A6, A7);
		typedef R (*CallFunctionType)(A4, A5, A6, A7);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef FunctionBinder<FunctionType, 3> ThisType;
	private:
		BaseFunctionHolder<FunctionType> * holder_;
		A1 a1_; A2 a2_; A3 a3_;
	public:
  FunctionBinder(const BaseFunctionHolder<FunctionType> * holder, A1 a1, A2 a2,
      A3 a3):
		holder_(holder->Clone()),
		a1_(a1), a2_(a2), a3_(a3)
		{
		}
		virtual ~FunctionBinder(){
			ICK_DELETE(holder_);
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, holder_, a1_, a2_, a3_);
		}
		virtual R operator() (A4 a4, A5 a5, A6 a6, A7 a7) {
			return (*holder_)(a1_, a2_, a3_, a4, a5, a6, a7);
		}
	};


	// 引数7個の関数に、4個の引数をbindして、
	// 引数3個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5, typename A6, typename A7>
	class FunctionBinder<R(*)(A1, A2, A3, A4, A5, A6, A7), 4> :
		public BaseFunctionHolder<R(*)(A5, A6, A7)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5, A6, A7);
		typedef R (*CallFunctionType)(A5, A6, A7);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef FunctionBinder<FunctionType, 4> ThisType;
	private:
		BaseFunctionHolder<FunctionType> * holder_;
		A1 a1_; A2 a2_; A3 a3_; A4 a4_;
	public:
  FunctionBinder(const BaseFunctionHolder<FunctionType> * holder, A1 a1, A2 a2,
      A3 a3, A4 a4):
		holder_(holder->Clone()),
		a1_(a1), a2_(a2), a3_(a3), a4_(a4)
		{
		}
		virtual ~FunctionBinder(){
			ICK_DELETE(holder_);
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, holder_, a1_, a2_, a3_, a4_);
		}
		virtual R operator() (A5 a5, A6 a6, A7 a7) {
			return (*holder_)(a1_, a2_, a3_, a4_, a5, a6, a7);
		}
	};


	// 引数7個の関数に、5個の引数をbindして、
	// 引数2個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5, typename A6, typename A7>
	class FunctionBinder<R(*)(A1, A2, A3, A4, A5, A6, A7), 5> :
		public BaseFunctionHolder<R(*)(A6, A7)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5, A6, A7);
		typedef R (*CallFunctionType)(A6, A7);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef FunctionBinder<FunctionType, 5> ThisType;
	private:
		BaseFunctionHolder<FunctionType> * holder_;
		A1 a1_; A2 a2_; A3 a3_; A4 a4_; A5 a5_;
	public:
  FunctionBinder(const BaseFunctionHolder<FunctionType> * holder, A1 a1, A2 a2,
      A3 a3, A4 a4, A5 a5):
		holder_(holder->Clone()),
		a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5)
		{
		}
		virtual ~FunctionBinder(){
			ICK_DELETE(holder_);
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, holder_, a1_, a2_, a3_, a4_, a5_);
		}
		virtual R operator() (A6 a6, A7 a7) {
			return (*holder_)(a1_, a2_, a3_, a4_, a5_, a6, a7);
		}
	};


	// 引数7個の関数に、6個の引数をbindして、
	// 引数1個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5, typename A6, typename A7>
	class FunctionBinder<R(*)(A1, A2, A3, A4, A5, A6, A7), 6> :
		public BaseFunctionHolder<R(*)(A7)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5, A6, A7);
		typedef R (*CallFunctionType)(A7);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef FunctionBinder<FunctionType, 6> ThisType;
	private:
		BaseFunctionHolder<FunctionType> * holder_;
		A1 a1_; A2 a2_; A3 a3_; A4 a4_; A5 a5_; A6 a6_;
	public:
  FunctionBinder(const BaseFunctionHolder<FunctionType> * holder, A1 a1, A2 a2,
      A3 a3, A4 a4, A5 a5, A6 a6):
		holder_(holder->Clone()),
		a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5), a6_(a6)
		{
		}
		virtual ~FunctionBinder(){
			ICK_DELETE(holder_);
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, holder_, a1_, a2_, a3_, a4_, a5_, a6_);
		}
		virtual R operator() (A7 a7) {
			return (*holder_)(a1_, a2_, a3_, a4_, a5_, a6_, a7);
		}
	};


	// 引数7個の関数に、7個の引数をbindして、
	// 引数0個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5, typename A6, typename A7>
	class FunctionBinder<R(*)(A1, A2, A3, A4, A5, A6, A7), 7> :
		public BaseFunctionHolder<R(*)()>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5, A6, A7);
		typedef R (*CallFunctionType)();
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef FunctionBinder<FunctionType, 7> ThisType;
	private:
		BaseFunctionHolder<FunctionType> * holder_;
		A1 a1_; A2 a2_; A3 a3_; A4 a4_; A5 a5_; A6 a6_; A7 a7_;
	public:
  FunctionBinder(const BaseFunctionHolder<FunctionType> * holder, A1 a1, A2 a2,
      A3 a3, A4 a4, A5 a5, A6 a6, A7 a7):
		holder_(holder->Clone()),
		a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5), a6_(a6), a7_(a7)
		{
		}
		virtual ~FunctionBinder(){
			ICK_DELETE(holder_);
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, holder_, a1_, a2_, a3_, a4_, a5_, a6_, a7_);
		}
		virtual R operator() () {
			return (*holder_)(a1_, a2_, a3_, a4_, a5_, a6_, a7_);
		}
	};


	// 引数8個の関数に、1個の引数をbindして、
	// 引数7個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5, typename A6, typename A7, typename A8>
	class FunctionBinder<R(*)(A1, A2, A3, A4, A5, A6, A7, A8), 1> :
		public BaseFunctionHolder<R(*)(A2, A3, A4, A5, A6, A7, A8)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5, A6, A7, A8);
		typedef R (*CallFunctionType)(A2, A3, A4, A5, A6, A7, A8);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef FunctionBinder<FunctionType, 1> ThisType;
	private:
		BaseFunctionHolder<FunctionType> * holder_;
		A1 a1_;
	public:
		FunctionBinder(const BaseFunctionHolder<FunctionType> * holder, A1 a1):
		holder_(holder->Clone()),
		a1_(a1)
		{
		}
		virtual ~FunctionBinder(){
			ICK_DELETE(holder_);
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, holder_, a1_);
		}
		virtual R operator() (A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) {
			return (*holder_)(a1_, a2, a3, a4, a5, a6, a7, a8);
		}
	};


	// 引数8個の関数に、2個の引数をbindして、
	// 引数6個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5, typename A6, typename A7, typename A8>
	class FunctionBinder<R(*)(A1, A2, A3, A4, A5, A6, A7, A8), 2> :
		public BaseFunctionHolder<R(*)(A3, A4, A5, A6, A7, A8)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5, A6, A7, A8);
		typedef R (*CallFunctionType)(A3, A4, A5, A6, A7, A8);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef FunctionBinder<FunctionType, 2> ThisType;
	private:
		BaseFunctionHolder<FunctionType> * holder_;
		A1 a1_; A2 a2_;
	public:
		FunctionBinder(const BaseFunctionHolder<FunctionType> * holder, A1 a1, A2 a2):
		holder_(holder->Clone()),
		a1_(a1), a2_(a2)
		{
		}
		virtual ~FunctionBinder(){
			ICK_DELETE(holder_);
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, holder_, a1_, a2_);
		}
		virtual R operator() (A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) {
			return (*holder_)(a1_, a2_, a3, a4, a5, a6, a7, a8);
		}
	};


	// 引数8個の関数に、3個の引数をbindして、
	// 引数5個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5, typename A6, typename A7, typename A8>
	class FunctionBinder<R(*)(A1, A2, A3, A4, A5, A6, A7, A8), 3> :
		public BaseFunctionHolder<R(*)(A4, A5, A6, A7, A8)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5, A6, A7, A8);
		typedef R (*CallFunctionType)(A4, A5, A6, A7, A8);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef FunctionBinder<FunctionType, 3> ThisType;
	private:
		BaseFunctionHolder<FunctionType> * holder_;
		A1 a1_; A2 a2_; A3 a3_;
	public:
  FunctionBinder(const BaseFunctionHolder<FunctionType> * holder, A1 a1, A2 a2,
      A3 a3):
		holder_(holder->Clone()),
		a1_(a1), a2_(a2), a3_(a3)
		{
		}
		virtual ~FunctionBinder(){
			ICK_DELETE(holder_);
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, holder_, a1_, a2_, a3_);
		}
		virtual R operator() (A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) {
			return (*holder_)(a1_, a2_, a3_, a4, a5, a6, a7, a8);
		}
	};


	// 引数8個の関数に、4個の引数をbindして、
	// 引数4個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5, typename A6, typename A7, typename A8>
	class FunctionBinder<R(*)(A1, A2, A3, A4, A5, A6, A7, A8), 4> :
		public BaseFunctionHolder<R(*)(A5, A6, A7, A8)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5, A6, A7, A8);
		typedef R (*CallFunctionType)(A5, A6, A7, A8);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef FunctionBinder<FunctionType, 4> ThisType;
	private:
		BaseFunctionHolder<FunctionType> * holder_;
		A1 a1_; A2 a2_; A3 a3_; A4 a4_;
	public:
  FunctionBinder(const BaseFunctionHolder<FunctionType> * holder, A1 a1, A2 a2,
      A3 a3, A4 a4):
		holder_(holder->Clone()),
		a1_(a1), a2_(a2), a3_(a3), a4_(a4)
		{
		}
		virtual ~FunctionBinder(){
			ICK_DELETE(holder_);
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, holder_, a1_, a2_, a3_, a4_);
		}
		virtual R operator() (A5 a5, A6 a6, A7 a7, A8 a8) {
			return (*holder_)(a1_, a2_, a3_, a4_, a5, a6, a7, a8);
		}
	};


	// 引数8個の関数に、5個の引数をbindして、
	// 引数3個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5, typename A6, typename A7, typename A8>
	class FunctionBinder<R(*)(A1, A2, A3, A4, A5, A6, A7, A8), 5> :
		public BaseFunctionHolder<R(*)(A6, A7, A8)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5, A6, A7, A8);
		typedef R (*CallFunctionType)(A6, A7, A8);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef FunctionBinder<FunctionType, 5> ThisType;
	private:
		BaseFunctionHolder<FunctionType> * holder_;
		A1 a1_; A2 a2_; A3 a3_; A4 a4_; A5 a5_;
	public:
  FunctionBinder(const BaseFunctionHolder<FunctionType> * holder, A1 a1, A2 a2,
      A3 a3, A4 a4, A5 a5):
		holder_(holder->Clone()),
		a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5)
		{
		}
		virtual ~FunctionBinder(){
			ICK_DELETE(holder_);
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, holder_, a1_, a2_, a3_, a4_, a5_);
		}
		virtual R operator() (A6 a6, A7 a7, A8 a8) {
			return (*holder_)(a1_, a2_, a3_, a4_, a5_, a6, a7, a8);
		}
	};


	// 引数8個の関数に、6個の引数をbindして、
	// 引数2個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5, typename A6, typename A7, typename A8>
	class FunctionBinder<R(*)(A1, A2, A3, A4, A5, A6, A7, A8), 6> :
		public BaseFunctionHolder<R(*)(A7, A8)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5, A6, A7, A8);
		typedef R (*CallFunctionType)(A7, A8);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef FunctionBinder<FunctionType, 6> ThisType;
	private:
		BaseFunctionHolder<FunctionType> * holder_;
		A1 a1_; A2 a2_; A3 a3_; A4 a4_; A5 a5_; A6 a6_;
	public:
  FunctionBinder(const BaseFunctionHolder<FunctionType> * holder, A1 a1, A2 a2,
      A3 a3, A4 a4, A5 a5, A6 a6):
		holder_(holder->Clone()),
		a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5), a6_(a6)
		{
		}
		virtual ~FunctionBinder(){
			ICK_DELETE(holder_);
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, holder_, a1_, a2_, a3_, a4_, a5_, a6_);
		}
		virtual R operator() (A7 a7, A8 a8) {
			return (*holder_)(a1_, a2_, a3_, a4_, a5_, a6_, a7, a8);
		}
	};


	// 引数8個の関数に、7個の引数をbindして、
	// 引数1個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5, typename A6, typename A7, typename A8>
	class FunctionBinder<R(*)(A1, A2, A3, A4, A5, A6, A7, A8), 7> :
		public BaseFunctionHolder<R(*)(A8)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5, A6, A7, A8);
		typedef R (*CallFunctionType)(A8);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef FunctionBinder<FunctionType, 7> ThisType;
	private:
		BaseFunctionHolder<FunctionType> * holder_;
		A1 a1_; A2 a2_; A3 a3_; A4 a4_; A5 a5_; A6 a6_; A7 a7_;
	public:
  FunctionBinder(const BaseFunctionHolder<FunctionType> * holder, A1 a1, A2 a2,
      A3 a3, A4 a4, A5 a5, A6 a6, A7 a7):
		holder_(holder->Clone()),
		a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5), a6_(a6), a7_(a7)
		{
		}
		virtual ~FunctionBinder(){
			ICK_DELETE(holder_);
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, holder_, a1_, a2_, a3_, a4_, a5_, a6_, a7_);
		}
		virtual R operator() (A8 a8) {
			return (*holder_)(a1_, a2_, a3_, a4_, a5_, a6_, a7_, a8);
		}
	};


	// 引数8個の関数に、8個の引数をbindして、
	// 引数0個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5, typename A6, typename A7, typename A8>
	class FunctionBinder<R(*)(A1, A2, A3, A4, A5, A6, A7, A8), 8> :
		public BaseFunctionHolder<R(*)()>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5, A6, A7, A8);
		typedef R (*CallFunctionType)();
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef FunctionBinder<FunctionType, 8> ThisType;
	private:
		BaseFunctionHolder<FunctionType> * holder_;
		A1 a1_; A2 a2_; A3 a3_; A4 a4_; A5 a5_; A6 a6_; A7 a7_; A8 a8_;
	public:
  FunctionBinder(const BaseFunctionHolder<FunctionType> * holder, A1 a1, A2 a2,
      A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8):
		holder_(holder->Clone()),
		a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5), a6_(a6), a7_(a7), a8_(a8)
		{
		}
		virtual ~FunctionBinder(){
			ICK_DELETE(holder_);
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, holder_, a1_, a2_, a3_, a4_, a5_, a6_, a7_, a8_);
		}
		virtual R operator() () {
			return (*holder_)(a1_, a2_, a3_, a4_, a5_, a6_, a7_, a8_);
		}
	};


}
