#pragma once

#include "../base/memory.h"

namespace ick {
	template <typename FP> class BaseFunctorHolder;
	template <typename F, typename FP> class FunctorHolder;
	$var an_max = 8
	$range an 0..an_max
	$for an [[
	$range ai 1..an

	template <typename R$for ai [[, typename A$ai]]>
	class BaseFunctorHolder<R(*)($for ai , [[A$ai]])> {
	public:
		typedef R (*FunctionType)($for ai , [[A$ai]]);
		typedef BaseFunctorHolder<FunctionType> ThisType;
	private:
		ThisType & operator = (const ThisType & copy);
	public:
		virtual ~BaseFunctorHolder(){};
		virtual ThisType * Clone() const = 0;
		virtual R operator() ($for ai , [[A$ai a$ai]]) = 0;
	};

	template <typename F, typename R$for ai [[, typename A$ai]]>
	class FunctorHolder<F, R(*)($for ai , [[A$ai]])> : 
	public BaseFunctorHolder<R(*)($for ai , [[A$ai]])> {
	public:
		typedef R (*FunctionType)($for ai , [[A$ai]]);
		typedef BaseFunctorHolder<FunctionType> SuperType;
		typedef FunctorHolder<F, FunctionType> ThisType;
	private:
		F functor_;
	public:
		FunctorHolder(F functor):functor_(functor){}
		SuperType * Clone() const { return ICK_NEW(ThisType, functor_); }
		virtual R operator() ($for ai , [[A$ai a$ai]]) { 
			return functor_($for ai , [[a$ai]]); 
		}
	};
	]]


}
