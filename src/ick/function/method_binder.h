// This file was GENERATED by command:
//     pump.py method_binder.h.pump
// DO NOT EDIT BY HAND!!!

#pragma once

#include "../base/memory.h"

#include "base_function_holder.h"
#include "function.h"

namespace ick {
	template <typename F> class BaseFunctionHolder;
	template <typename F, int N> class MethodBinder;

	// 引数0個のメソッドに、
	// thisと0個の引数をbindして、
	// 引数0個の関数にする。
	template <class T, typename R>
	class MethodBinder<R(T::*)(), 0> :
		public BaseFunctionHolder<R(*)()>{
	public:
		typedef R (T::*MethodType)();
		typedef R (*CallFunctionType)();
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef MethodBinder<MethodType, 0> ThisType;
	private:
		MethodType method_;
		T * instance_;

	public:
		MethodBinder(MethodType method, T * instance):
		method_(method),
		instance_(instance)
		{
		}
		virtual ~MethodBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, method_, instance_);
		}
		virtual R operator() () {
			return (instance_->*method_)();
		}
	};


	// 引数1個のメソッドに、
	// thisと0個の引数をbindして、
	// 引数1個の関数にする。
	template <class T, typename R, typename A1>
	class MethodBinder<R(T::*)(A1), 0> :
		public BaseFunctionHolder<R(*)(A1)>{
	public:
		typedef R (T::*MethodType)(A1);
		typedef R (*CallFunctionType)(A1);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef MethodBinder<MethodType, 0> ThisType;
	private:
		MethodType method_;
		T * instance_;

	public:
		MethodBinder(MethodType method, T * instance):
		method_(method),
		instance_(instance)
		{
		}
		virtual ~MethodBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, method_, instance_);
		}
		virtual R operator() (A1 a1) {
			return (instance_->*method_)(a1);
		}
	};


	// 引数1個のメソッドに、
	// thisと1個の引数をbindして、
	// 引数0個の関数にする。
	template <class T, typename R, typename A1>
	class MethodBinder<R(T::*)(A1), 1> :
		public BaseFunctionHolder<R(*)()>{
	public:
		typedef R (T::*MethodType)(A1);
		typedef R (*CallFunctionType)();
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef MethodBinder<MethodType, 1> ThisType;
	private:
		MethodType method_;
		T * instance_;
		A1 a1_;
	public:
		MethodBinder(MethodType method, T * instance, A1 a1):
		method_(method),
		instance_(instance),
		a1_(a1)
		{
		}
		virtual ~MethodBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, method_, instance_, a1_);
		}
		virtual R operator() () {
			return (instance_->*method_)(a1_);
		}
	};


	// 引数2個のメソッドに、
	// thisと0個の引数をbindして、
	// 引数2個の関数にする。
	template <class T, typename R, typename A1, typename A2>
	class MethodBinder<R(T::*)(A1, A2), 0> :
		public BaseFunctionHolder<R(*)(A1, A2)>{
	public:
		typedef R (T::*MethodType)(A1, A2);
		typedef R (*CallFunctionType)(A1, A2);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef MethodBinder<MethodType, 0> ThisType;
	private:
		MethodType method_;
		T * instance_;

	public:
		MethodBinder(MethodType method, T * instance):
		method_(method),
		instance_(instance)
		{
		}
		virtual ~MethodBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, method_, instance_);
		}
		virtual R operator() (A1 a1, A2 a2) {
			return (instance_->*method_)(a1, a2);
		}
	};


	// 引数2個のメソッドに、
	// thisと1個の引数をbindして、
	// 引数1個の関数にする。
	template <class T, typename R, typename A1, typename A2>
	class MethodBinder<R(T::*)(A1, A2), 1> :
		public BaseFunctionHolder<R(*)(A2)>{
	public:
		typedef R (T::*MethodType)(A1, A2);
		typedef R (*CallFunctionType)(A2);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef MethodBinder<MethodType, 1> ThisType;
	private:
		MethodType method_;
		T * instance_;
		A1 a1_;
	public:
		MethodBinder(MethodType method, T * instance, A1 a1):
		method_(method),
		instance_(instance),
		a1_(a1)
		{
		}
		virtual ~MethodBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, method_, instance_, a1_);
		}
		virtual R operator() (A2 a2) {
			return (instance_->*method_)(a1_, a2);
		}
	};


	// 引数2個のメソッドに、
	// thisと2個の引数をbindして、
	// 引数0個の関数にする。
	template <class T, typename R, typename A1, typename A2>
	class MethodBinder<R(T::*)(A1, A2), 2> :
		public BaseFunctionHolder<R(*)()>{
	public:
		typedef R (T::*MethodType)(A1, A2);
		typedef R (*CallFunctionType)();
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef MethodBinder<MethodType, 2> ThisType;
	private:
		MethodType method_;
		T * instance_;
		A1 a1_; A2 a2_;
	public:
		MethodBinder(MethodType method, T * instance, A1 a1, A2 a2):
		method_(method),
		instance_(instance),
		a1_(a1), a2_(a2)
		{
		}
		virtual ~MethodBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, method_, instance_, a1_, a2_);
		}
		virtual R operator() () {
			return (instance_->*method_)(a1_, a2_);
		}
	};


	// 引数3個のメソッドに、
	// thisと0個の引数をbindして、
	// 引数3個の関数にする。
	template <class T, typename R, typename A1, typename A2, typename A3>
	class MethodBinder<R(T::*)(A1, A2, A3), 0> :
		public BaseFunctionHolder<R(*)(A1, A2, A3)>{
	public:
		typedef R (T::*MethodType)(A1, A2, A3);
		typedef R (*CallFunctionType)(A1, A2, A3);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef MethodBinder<MethodType, 0> ThisType;
	private:
		MethodType method_;
		T * instance_;

	public:
		MethodBinder(MethodType method, T * instance):
		method_(method),
		instance_(instance)
		{
		}
		virtual ~MethodBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, method_, instance_);
		}
		virtual R operator() (A1 a1, A2 a2, A3 a3) {
			return (instance_->*method_)(a1, a2, a3);
		}
	};


	// 引数3個のメソッドに、
	// thisと1個の引数をbindして、
	// 引数2個の関数にする。
	template <class T, typename R, typename A1, typename A2, typename A3>
	class MethodBinder<R(T::*)(A1, A2, A3), 1> :
		public BaseFunctionHolder<R(*)(A2, A3)>{
	public:
		typedef R (T::*MethodType)(A1, A2, A3);
		typedef R (*CallFunctionType)(A2, A3);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef MethodBinder<MethodType, 1> ThisType;
	private:
		MethodType method_;
		T * instance_;
		A1 a1_;
	public:
		MethodBinder(MethodType method, T * instance, A1 a1):
		method_(method),
		instance_(instance),
		a1_(a1)
		{
		}
		virtual ~MethodBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, method_, instance_, a1_);
		}
		virtual R operator() (A2 a2, A3 a3) {
			return (instance_->*method_)(a1_, a2, a3);
		}
	};


	// 引数3個のメソッドに、
	// thisと2個の引数をbindして、
	// 引数1個の関数にする。
	template <class T, typename R, typename A1, typename A2, typename A3>
	class MethodBinder<R(T::*)(A1, A2, A3), 2> :
		public BaseFunctionHolder<R(*)(A3)>{
	public:
		typedef R (T::*MethodType)(A1, A2, A3);
		typedef R (*CallFunctionType)(A3);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef MethodBinder<MethodType, 2> ThisType;
	private:
		MethodType method_;
		T * instance_;
		A1 a1_; A2 a2_;
	public:
		MethodBinder(MethodType method, T * instance, A1 a1, A2 a2):
		method_(method),
		instance_(instance),
		a1_(a1), a2_(a2)
		{
		}
		virtual ~MethodBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, method_, instance_, a1_, a2_);
		}
		virtual R operator() (A3 a3) {
			return (instance_->*method_)(a1_, a2_, a3);
		}
	};


	// 引数3個のメソッドに、
	// thisと3個の引数をbindして、
	// 引数0個の関数にする。
	template <class T, typename R, typename A1, typename A2, typename A3>
	class MethodBinder<R(T::*)(A1, A2, A3), 3> :
		public BaseFunctionHolder<R(*)()>{
	public:
		typedef R (T::*MethodType)(A1, A2, A3);
		typedef R (*CallFunctionType)();
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef MethodBinder<MethodType, 3> ThisType;
	private:
		MethodType method_;
		T * instance_;
		A1 a1_; A2 a2_; A3 a3_;
	public:
		MethodBinder(MethodType method, T * instance, A1 a1, A2 a2, A3 a3):
		method_(method),
		instance_(instance),
		a1_(a1), a2_(a2), a3_(a3)
		{
		}
		virtual ~MethodBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, method_, instance_, a1_, a2_, a3_);
		}
		virtual R operator() () {
			return (instance_->*method_)(a1_, a2_, a3_);
		}
	};


	// 引数4個のメソッドに、
	// thisと0個の引数をbindして、
	// 引数4個の関数にする。
 template <class T, typename R, typename A1, typename A2, typename A3,
     typename A4>
	class MethodBinder<R(T::*)(A1, A2, A3, A4), 0> :
		public BaseFunctionHolder<R(*)(A1, A2, A3, A4)>{
	public:
		typedef R (T::*MethodType)(A1, A2, A3, A4);
		typedef R (*CallFunctionType)(A1, A2, A3, A4);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef MethodBinder<MethodType, 0> ThisType;
	private:
		MethodType method_;
		T * instance_;

	public:
		MethodBinder(MethodType method, T * instance):
		method_(method),
		instance_(instance)
		{
		}
		virtual ~MethodBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, method_, instance_);
		}
		virtual R operator() (A1 a1, A2 a2, A3 a3, A4 a4) {
			return (instance_->*method_)(a1, a2, a3, a4);
		}
	};


	// 引数4個のメソッドに、
	// thisと1個の引数をbindして、
	// 引数3個の関数にする。
 template <class T, typename R, typename A1, typename A2, typename A3,
     typename A4>
	class MethodBinder<R(T::*)(A1, A2, A3, A4), 1> :
		public BaseFunctionHolder<R(*)(A2, A3, A4)>{
	public:
		typedef R (T::*MethodType)(A1, A2, A3, A4);
		typedef R (*CallFunctionType)(A2, A3, A4);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef MethodBinder<MethodType, 1> ThisType;
	private:
		MethodType method_;
		T * instance_;
		A1 a1_;
	public:
		MethodBinder(MethodType method, T * instance, A1 a1):
		method_(method),
		instance_(instance),
		a1_(a1)
		{
		}
		virtual ~MethodBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, method_, instance_, a1_);
		}
		virtual R operator() (A2 a2, A3 a3, A4 a4) {
			return (instance_->*method_)(a1_, a2, a3, a4);
		}
	};


	// 引数4個のメソッドに、
	// thisと2個の引数をbindして、
	// 引数2個の関数にする。
 template <class T, typename R, typename A1, typename A2, typename A3,
     typename A4>
	class MethodBinder<R(T::*)(A1, A2, A3, A4), 2> :
		public BaseFunctionHolder<R(*)(A3, A4)>{
	public:
		typedef R (T::*MethodType)(A1, A2, A3, A4);
		typedef R (*CallFunctionType)(A3, A4);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef MethodBinder<MethodType, 2> ThisType;
	private:
		MethodType method_;
		T * instance_;
		A1 a1_; A2 a2_;
	public:
		MethodBinder(MethodType method, T * instance, A1 a1, A2 a2):
		method_(method),
		instance_(instance),
		a1_(a1), a2_(a2)
		{
		}
		virtual ~MethodBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, method_, instance_, a1_, a2_);
		}
		virtual R operator() (A3 a3, A4 a4) {
			return (instance_->*method_)(a1_, a2_, a3, a4);
		}
	};


	// 引数4個のメソッドに、
	// thisと3個の引数をbindして、
	// 引数1個の関数にする。
 template <class T, typename R, typename A1, typename A2, typename A3,
     typename A4>
	class MethodBinder<R(T::*)(A1, A2, A3, A4), 3> :
		public BaseFunctionHolder<R(*)(A4)>{
	public:
		typedef R (T::*MethodType)(A1, A2, A3, A4);
		typedef R (*CallFunctionType)(A4);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef MethodBinder<MethodType, 3> ThisType;
	private:
		MethodType method_;
		T * instance_;
		A1 a1_; A2 a2_; A3 a3_;
	public:
		MethodBinder(MethodType method, T * instance, A1 a1, A2 a2, A3 a3):
		method_(method),
		instance_(instance),
		a1_(a1), a2_(a2), a3_(a3)
		{
		}
		virtual ~MethodBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, method_, instance_, a1_, a2_, a3_);
		}
		virtual R operator() (A4 a4) {
			return (instance_->*method_)(a1_, a2_, a3_, a4);
		}
	};


	// 引数4個のメソッドに、
	// thisと4個の引数をbindして、
	// 引数0個の関数にする。
 template <class T, typename R, typename A1, typename A2, typename A3,
     typename A4>
	class MethodBinder<R(T::*)(A1, A2, A3, A4), 4> :
		public BaseFunctionHolder<R(*)()>{
	public:
		typedef R (T::*MethodType)(A1, A2, A3, A4);
		typedef R (*CallFunctionType)();
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef MethodBinder<MethodType, 4> ThisType;
	private:
		MethodType method_;
		T * instance_;
		A1 a1_; A2 a2_; A3 a3_; A4 a4_;
	public:
		MethodBinder(MethodType method, T * instance, A1 a1, A2 a2, A3 a3, A4 a4):
		method_(method),
		instance_(instance),
		a1_(a1), a2_(a2), a3_(a3), a4_(a4)
		{
		}
		virtual ~MethodBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, method_, instance_, a1_, a2_, a3_, a4_);
		}
		virtual R operator() () {
			return (instance_->*method_)(a1_, a2_, a3_, a4_);
		}
	};


	// 引数5個のメソッドに、
	// thisと0個の引数をbindして、
	// 引数5個の関数にする。
 template <class T, typename R, typename A1, typename A2, typename A3,
     typename A4, typename A5>
	class MethodBinder<R(T::*)(A1, A2, A3, A4, A5), 0> :
		public BaseFunctionHolder<R(*)(A1, A2, A3, A4, A5)>{
	public:
		typedef R (T::*MethodType)(A1, A2, A3, A4, A5);
		typedef R (*CallFunctionType)(A1, A2, A3, A4, A5);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef MethodBinder<MethodType, 0> ThisType;
	private:
		MethodType method_;
		T * instance_;

	public:
		MethodBinder(MethodType method, T * instance):
		method_(method),
		instance_(instance)
		{
		}
		virtual ~MethodBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, method_, instance_);
		}
		virtual R operator() (A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) {
			return (instance_->*method_)(a1, a2, a3, a4, a5);
		}
	};


	// 引数5個のメソッドに、
	// thisと1個の引数をbindして、
	// 引数4個の関数にする。
 template <class T, typename R, typename A1, typename A2, typename A3,
     typename A4, typename A5>
	class MethodBinder<R(T::*)(A1, A2, A3, A4, A5), 1> :
		public BaseFunctionHolder<R(*)(A2, A3, A4, A5)>{
	public:
		typedef R (T::*MethodType)(A1, A2, A3, A4, A5);
		typedef R (*CallFunctionType)(A2, A3, A4, A5);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef MethodBinder<MethodType, 1> ThisType;
	private:
		MethodType method_;
		T * instance_;
		A1 a1_;
	public:
		MethodBinder(MethodType method, T * instance, A1 a1):
		method_(method),
		instance_(instance),
		a1_(a1)
		{
		}
		virtual ~MethodBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, method_, instance_, a1_);
		}
		virtual R operator() (A2 a2, A3 a3, A4 a4, A5 a5) {
			return (instance_->*method_)(a1_, a2, a3, a4, a5);
		}
	};


	// 引数5個のメソッドに、
	// thisと2個の引数をbindして、
	// 引数3個の関数にする。
 template <class T, typename R, typename A1, typename A2, typename A3,
     typename A4, typename A5>
	class MethodBinder<R(T::*)(A1, A2, A3, A4, A5), 2> :
		public BaseFunctionHolder<R(*)(A3, A4, A5)>{
	public:
		typedef R (T::*MethodType)(A1, A2, A3, A4, A5);
		typedef R (*CallFunctionType)(A3, A4, A5);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef MethodBinder<MethodType, 2> ThisType;
	private:
		MethodType method_;
		T * instance_;
		A1 a1_; A2 a2_;
	public:
		MethodBinder(MethodType method, T * instance, A1 a1, A2 a2):
		method_(method),
		instance_(instance),
		a1_(a1), a2_(a2)
		{
		}
		virtual ~MethodBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, method_, instance_, a1_, a2_);
		}
		virtual R operator() (A3 a3, A4 a4, A5 a5) {
			return (instance_->*method_)(a1_, a2_, a3, a4, a5);
		}
	};


	// 引数5個のメソッドに、
	// thisと3個の引数をbindして、
	// 引数2個の関数にする。
 template <class T, typename R, typename A1, typename A2, typename A3,
     typename A4, typename A5>
	class MethodBinder<R(T::*)(A1, A2, A3, A4, A5), 3> :
		public BaseFunctionHolder<R(*)(A4, A5)>{
	public:
		typedef R (T::*MethodType)(A1, A2, A3, A4, A5);
		typedef R (*CallFunctionType)(A4, A5);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef MethodBinder<MethodType, 3> ThisType;
	private:
		MethodType method_;
		T * instance_;
		A1 a1_; A2 a2_; A3 a3_;
	public:
		MethodBinder(MethodType method, T * instance, A1 a1, A2 a2, A3 a3):
		method_(method),
		instance_(instance),
		a1_(a1), a2_(a2), a3_(a3)
		{
		}
		virtual ~MethodBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, method_, instance_, a1_, a2_, a3_);
		}
		virtual R operator() (A4 a4, A5 a5) {
			return (instance_->*method_)(a1_, a2_, a3_, a4, a5);
		}
	};


	// 引数5個のメソッドに、
	// thisと4個の引数をbindして、
	// 引数1個の関数にする。
 template <class T, typename R, typename A1, typename A2, typename A3,
     typename A4, typename A5>
	class MethodBinder<R(T::*)(A1, A2, A3, A4, A5), 4> :
		public BaseFunctionHolder<R(*)(A5)>{
	public:
		typedef R (T::*MethodType)(A1, A2, A3, A4, A5);
		typedef R (*CallFunctionType)(A5);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef MethodBinder<MethodType, 4> ThisType;
	private:
		MethodType method_;
		T * instance_;
		A1 a1_; A2 a2_; A3 a3_; A4 a4_;
	public:
		MethodBinder(MethodType method, T * instance, A1 a1, A2 a2, A3 a3, A4 a4):
		method_(method),
		instance_(instance),
		a1_(a1), a2_(a2), a3_(a3), a4_(a4)
		{
		}
		virtual ~MethodBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, method_, instance_, a1_, a2_, a3_, a4_);
		}
		virtual R operator() (A5 a5) {
			return (instance_->*method_)(a1_, a2_, a3_, a4_, a5);
		}
	};


	// 引数5個のメソッドに、
	// thisと5個の引数をbindして、
	// 引数0個の関数にする。
 template <class T, typename R, typename A1, typename A2, typename A3,
     typename A4, typename A5>
	class MethodBinder<R(T::*)(A1, A2, A3, A4, A5), 5> :
		public BaseFunctionHolder<R(*)()>{
	public:
		typedef R (T::*MethodType)(A1, A2, A3, A4, A5);
		typedef R (*CallFunctionType)();
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef MethodBinder<MethodType, 5> ThisType;
	private:
		MethodType method_;
		T * instance_;
		A1 a1_; A2 a2_; A3 a3_; A4 a4_; A5 a5_;
	public:
  MethodBinder(MethodType method, T * instance, A1 a1, A2 a2, A3 a3, A4 a4,
      A5 a5):
		method_(method),
		instance_(instance),
		a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5)
		{
		}
		virtual ~MethodBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, method_, instance_, a1_, a2_, a3_, a4_, a5_);
		}
		virtual R operator() () {
			return (instance_->*method_)(a1_, a2_, a3_, a4_, a5_);
		}
	};


	// 引数6個のメソッドに、
	// thisと0個の引数をbindして、
	// 引数6個の関数にする。
 template <class T, typename R, typename A1, typename A2, typename A3,
     typename A4, typename A5, typename A6>
	class MethodBinder<R(T::*)(A1, A2, A3, A4, A5, A6), 0> :
		public BaseFunctionHolder<R(*)(A1, A2, A3, A4, A5, A6)>{
	public:
		typedef R (T::*MethodType)(A1, A2, A3, A4, A5, A6);
		typedef R (*CallFunctionType)(A1, A2, A3, A4, A5, A6);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef MethodBinder<MethodType, 0> ThisType;
	private:
		MethodType method_;
		T * instance_;

	public:
		MethodBinder(MethodType method, T * instance):
		method_(method),
		instance_(instance)
		{
		}
		virtual ~MethodBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, method_, instance_);
		}
		virtual R operator() (A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) {
			return (instance_->*method_)(a1, a2, a3, a4, a5, a6);
		}
	};


	// 引数6個のメソッドに、
	// thisと1個の引数をbindして、
	// 引数5個の関数にする。
 template <class T, typename R, typename A1, typename A2, typename A3,
     typename A4, typename A5, typename A6>
	class MethodBinder<R(T::*)(A1, A2, A3, A4, A5, A6), 1> :
		public BaseFunctionHolder<R(*)(A2, A3, A4, A5, A6)>{
	public:
		typedef R (T::*MethodType)(A1, A2, A3, A4, A5, A6);
		typedef R (*CallFunctionType)(A2, A3, A4, A5, A6);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef MethodBinder<MethodType, 1> ThisType;
	private:
		MethodType method_;
		T * instance_;
		A1 a1_;
	public:
		MethodBinder(MethodType method, T * instance, A1 a1):
		method_(method),
		instance_(instance),
		a1_(a1)
		{
		}
		virtual ~MethodBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, method_, instance_, a1_);
		}
		virtual R operator() (A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) {
			return (instance_->*method_)(a1_, a2, a3, a4, a5, a6);
		}
	};


	// 引数6個のメソッドに、
	// thisと2個の引数をbindして、
	// 引数4個の関数にする。
 template <class T, typename R, typename A1, typename A2, typename A3,
     typename A4, typename A5, typename A6>
	class MethodBinder<R(T::*)(A1, A2, A3, A4, A5, A6), 2> :
		public BaseFunctionHolder<R(*)(A3, A4, A5, A6)>{
	public:
		typedef R (T::*MethodType)(A1, A2, A3, A4, A5, A6);
		typedef R (*CallFunctionType)(A3, A4, A5, A6);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef MethodBinder<MethodType, 2> ThisType;
	private:
		MethodType method_;
		T * instance_;
		A1 a1_; A2 a2_;
	public:
		MethodBinder(MethodType method, T * instance, A1 a1, A2 a2):
		method_(method),
		instance_(instance),
		a1_(a1), a2_(a2)
		{
		}
		virtual ~MethodBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, method_, instance_, a1_, a2_);
		}
		virtual R operator() (A3 a3, A4 a4, A5 a5, A6 a6) {
			return (instance_->*method_)(a1_, a2_, a3, a4, a5, a6);
		}
	};


	// 引数6個のメソッドに、
	// thisと3個の引数をbindして、
	// 引数3個の関数にする。
 template <class T, typename R, typename A1, typename A2, typename A3,
     typename A4, typename A5, typename A6>
	class MethodBinder<R(T::*)(A1, A2, A3, A4, A5, A6), 3> :
		public BaseFunctionHolder<R(*)(A4, A5, A6)>{
	public:
		typedef R (T::*MethodType)(A1, A2, A3, A4, A5, A6);
		typedef R (*CallFunctionType)(A4, A5, A6);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef MethodBinder<MethodType, 3> ThisType;
	private:
		MethodType method_;
		T * instance_;
		A1 a1_; A2 a2_; A3 a3_;
	public:
		MethodBinder(MethodType method, T * instance, A1 a1, A2 a2, A3 a3):
		method_(method),
		instance_(instance),
		a1_(a1), a2_(a2), a3_(a3)
		{
		}
		virtual ~MethodBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, method_, instance_, a1_, a2_, a3_);
		}
		virtual R operator() (A4 a4, A5 a5, A6 a6) {
			return (instance_->*method_)(a1_, a2_, a3_, a4, a5, a6);
		}
	};


	// 引数6個のメソッドに、
	// thisと4個の引数をbindして、
	// 引数2個の関数にする。
 template <class T, typename R, typename A1, typename A2, typename A3,
     typename A4, typename A5, typename A6>
	class MethodBinder<R(T::*)(A1, A2, A3, A4, A5, A6), 4> :
		public BaseFunctionHolder<R(*)(A5, A6)>{
	public:
		typedef R (T::*MethodType)(A1, A2, A3, A4, A5, A6);
		typedef R (*CallFunctionType)(A5, A6);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef MethodBinder<MethodType, 4> ThisType;
	private:
		MethodType method_;
		T * instance_;
		A1 a1_; A2 a2_; A3 a3_; A4 a4_;
	public:
		MethodBinder(MethodType method, T * instance, A1 a1, A2 a2, A3 a3, A4 a4):
		method_(method),
		instance_(instance),
		a1_(a1), a2_(a2), a3_(a3), a4_(a4)
		{
		}
		virtual ~MethodBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, method_, instance_, a1_, a2_, a3_, a4_);
		}
		virtual R operator() (A5 a5, A6 a6) {
			return (instance_->*method_)(a1_, a2_, a3_, a4_, a5, a6);
		}
	};


	// 引数6個のメソッドに、
	// thisと5個の引数をbindして、
	// 引数1個の関数にする。
 template <class T, typename R, typename A1, typename A2, typename A3,
     typename A4, typename A5, typename A6>
	class MethodBinder<R(T::*)(A1, A2, A3, A4, A5, A6), 5> :
		public BaseFunctionHolder<R(*)(A6)>{
	public:
		typedef R (T::*MethodType)(A1, A2, A3, A4, A5, A6);
		typedef R (*CallFunctionType)(A6);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef MethodBinder<MethodType, 5> ThisType;
	private:
		MethodType method_;
		T * instance_;
		A1 a1_; A2 a2_; A3 a3_; A4 a4_; A5 a5_;
	public:
  MethodBinder(MethodType method, T * instance, A1 a1, A2 a2, A3 a3, A4 a4,
      A5 a5):
		method_(method),
		instance_(instance),
		a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5)
		{
		}
		virtual ~MethodBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, method_, instance_, a1_, a2_, a3_, a4_, a5_);
		}
		virtual R operator() (A6 a6) {
			return (instance_->*method_)(a1_, a2_, a3_, a4_, a5_, a6);
		}
	};


	// 引数6個のメソッドに、
	// thisと6個の引数をbindして、
	// 引数0個の関数にする。
 template <class T, typename R, typename A1, typename A2, typename A3,
     typename A4, typename A5, typename A6>
	class MethodBinder<R(T::*)(A1, A2, A3, A4, A5, A6), 6> :
		public BaseFunctionHolder<R(*)()>{
	public:
		typedef R (T::*MethodType)(A1, A2, A3, A4, A5, A6);
		typedef R (*CallFunctionType)();
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef MethodBinder<MethodType, 6> ThisType;
	private:
		MethodType method_;
		T * instance_;
		A1 a1_; A2 a2_; A3 a3_; A4 a4_; A5 a5_; A6 a6_;
	public:
  MethodBinder(MethodType method, T * instance, A1 a1, A2 a2, A3 a3, A4 a4,
      A5 a5, A6 a6):
		method_(method),
		instance_(instance),
		a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5), a6_(a6)
		{
		}
		virtual ~MethodBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, method_, instance_, a1_, a2_, a3_, a4_, a5_, a6_);
		}
		virtual R operator() () {
			return (instance_->*method_)(a1_, a2_, a3_, a4_, a5_, a6_);
		}
	};


	// 引数7個のメソッドに、
	// thisと0個の引数をbindして、
	// 引数7個の関数にする。
 template <class T, typename R, typename A1, typename A2, typename A3,
     typename A4, typename A5, typename A6, typename A7>
	class MethodBinder<R(T::*)(A1, A2, A3, A4, A5, A6, A7), 0> :
		public BaseFunctionHolder<R(*)(A1, A2, A3, A4, A5, A6, A7)>{
	public:
		typedef R (T::*MethodType)(A1, A2, A3, A4, A5, A6, A7);
		typedef R (*CallFunctionType)(A1, A2, A3, A4, A5, A6, A7);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef MethodBinder<MethodType, 0> ThisType;
	private:
		MethodType method_;
		T * instance_;

	public:
		MethodBinder(MethodType method, T * instance):
		method_(method),
		instance_(instance)
		{
		}
		virtual ~MethodBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, method_, instance_);
		}
		virtual R operator() (A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) {
			return (instance_->*method_)(a1, a2, a3, a4, a5, a6, a7);
		}
	};


	// 引数7個のメソッドに、
	// thisと1個の引数をbindして、
	// 引数6個の関数にする。
 template <class T, typename R, typename A1, typename A2, typename A3,
     typename A4, typename A5, typename A6, typename A7>
	class MethodBinder<R(T::*)(A1, A2, A3, A4, A5, A6, A7), 1> :
		public BaseFunctionHolder<R(*)(A2, A3, A4, A5, A6, A7)>{
	public:
		typedef R (T::*MethodType)(A1, A2, A3, A4, A5, A6, A7);
		typedef R (*CallFunctionType)(A2, A3, A4, A5, A6, A7);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef MethodBinder<MethodType, 1> ThisType;
	private:
		MethodType method_;
		T * instance_;
		A1 a1_;
	public:
		MethodBinder(MethodType method, T * instance, A1 a1):
		method_(method),
		instance_(instance),
		a1_(a1)
		{
		}
		virtual ~MethodBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, method_, instance_, a1_);
		}
		virtual R operator() (A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) {
			return (instance_->*method_)(a1_, a2, a3, a4, a5, a6, a7);
		}
	};


	// 引数7個のメソッドに、
	// thisと2個の引数をbindして、
	// 引数5個の関数にする。
 template <class T, typename R, typename A1, typename A2, typename A3,
     typename A4, typename A5, typename A6, typename A7>
	class MethodBinder<R(T::*)(A1, A2, A3, A4, A5, A6, A7), 2> :
		public BaseFunctionHolder<R(*)(A3, A4, A5, A6, A7)>{
	public:
		typedef R (T::*MethodType)(A1, A2, A3, A4, A5, A6, A7);
		typedef R (*CallFunctionType)(A3, A4, A5, A6, A7);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef MethodBinder<MethodType, 2> ThisType;
	private:
		MethodType method_;
		T * instance_;
		A1 a1_; A2 a2_;
	public:
		MethodBinder(MethodType method, T * instance, A1 a1, A2 a2):
		method_(method),
		instance_(instance),
		a1_(a1), a2_(a2)
		{
		}
		virtual ~MethodBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, method_, instance_, a1_, a2_);
		}
		virtual R operator() (A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) {
			return (instance_->*method_)(a1_, a2_, a3, a4, a5, a6, a7);
		}
	};


	// 引数7個のメソッドに、
	// thisと3個の引数をbindして、
	// 引数4個の関数にする。
 template <class T, typename R, typename A1, typename A2, typename A3,
     typename A4, typename A5, typename A6, typename A7>
	class MethodBinder<R(T::*)(A1, A2, A3, A4, A5, A6, A7), 3> :
		public BaseFunctionHolder<R(*)(A4, A5, A6, A7)>{
	public:
		typedef R (T::*MethodType)(A1, A2, A3, A4, A5, A6, A7);
		typedef R (*CallFunctionType)(A4, A5, A6, A7);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef MethodBinder<MethodType, 3> ThisType;
	private:
		MethodType method_;
		T * instance_;
		A1 a1_; A2 a2_; A3 a3_;
	public:
		MethodBinder(MethodType method, T * instance, A1 a1, A2 a2, A3 a3):
		method_(method),
		instance_(instance),
		a1_(a1), a2_(a2), a3_(a3)
		{
		}
		virtual ~MethodBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, method_, instance_, a1_, a2_, a3_);
		}
		virtual R operator() (A4 a4, A5 a5, A6 a6, A7 a7) {
			return (instance_->*method_)(a1_, a2_, a3_, a4, a5, a6, a7);
		}
	};


	// 引数7個のメソッドに、
	// thisと4個の引数をbindして、
	// 引数3個の関数にする。
 template <class T, typename R, typename A1, typename A2, typename A3,
     typename A4, typename A5, typename A6, typename A7>
	class MethodBinder<R(T::*)(A1, A2, A3, A4, A5, A6, A7), 4> :
		public BaseFunctionHolder<R(*)(A5, A6, A7)>{
	public:
		typedef R (T::*MethodType)(A1, A2, A3, A4, A5, A6, A7);
		typedef R (*CallFunctionType)(A5, A6, A7);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef MethodBinder<MethodType, 4> ThisType;
	private:
		MethodType method_;
		T * instance_;
		A1 a1_; A2 a2_; A3 a3_; A4 a4_;
	public:
		MethodBinder(MethodType method, T * instance, A1 a1, A2 a2, A3 a3, A4 a4):
		method_(method),
		instance_(instance),
		a1_(a1), a2_(a2), a3_(a3), a4_(a4)
		{
		}
		virtual ~MethodBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, method_, instance_, a1_, a2_, a3_, a4_);
		}
		virtual R operator() (A5 a5, A6 a6, A7 a7) {
			return (instance_->*method_)(a1_, a2_, a3_, a4_, a5, a6, a7);
		}
	};


	// 引数7個のメソッドに、
	// thisと5個の引数をbindして、
	// 引数2個の関数にする。
 template <class T, typename R, typename A1, typename A2, typename A3,
     typename A4, typename A5, typename A6, typename A7>
	class MethodBinder<R(T::*)(A1, A2, A3, A4, A5, A6, A7), 5> :
		public BaseFunctionHolder<R(*)(A6, A7)>{
	public:
		typedef R (T::*MethodType)(A1, A2, A3, A4, A5, A6, A7);
		typedef R (*CallFunctionType)(A6, A7);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef MethodBinder<MethodType, 5> ThisType;
	private:
		MethodType method_;
		T * instance_;
		A1 a1_; A2 a2_; A3 a3_; A4 a4_; A5 a5_;
	public:
  MethodBinder(MethodType method, T * instance, A1 a1, A2 a2, A3 a3, A4 a4,
      A5 a5):
		method_(method),
		instance_(instance),
		a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5)
		{
		}
		virtual ~MethodBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, method_, instance_, a1_, a2_, a3_, a4_, a5_);
		}
		virtual R operator() (A6 a6, A7 a7) {
			return (instance_->*method_)(a1_, a2_, a3_, a4_, a5_, a6, a7);
		}
	};


	// 引数7個のメソッドに、
	// thisと6個の引数をbindして、
	// 引数1個の関数にする。
 template <class T, typename R, typename A1, typename A2, typename A3,
     typename A4, typename A5, typename A6, typename A7>
	class MethodBinder<R(T::*)(A1, A2, A3, A4, A5, A6, A7), 6> :
		public BaseFunctionHolder<R(*)(A7)>{
	public:
		typedef R (T::*MethodType)(A1, A2, A3, A4, A5, A6, A7);
		typedef R (*CallFunctionType)(A7);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef MethodBinder<MethodType, 6> ThisType;
	private:
		MethodType method_;
		T * instance_;
		A1 a1_; A2 a2_; A3 a3_; A4 a4_; A5 a5_; A6 a6_;
	public:
  MethodBinder(MethodType method, T * instance, A1 a1, A2 a2, A3 a3, A4 a4,
      A5 a5, A6 a6):
		method_(method),
		instance_(instance),
		a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5), a6_(a6)
		{
		}
		virtual ~MethodBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, method_, instance_, a1_, a2_, a3_, a4_, a5_, a6_);
		}
		virtual R operator() (A7 a7) {
			return (instance_->*method_)(a1_, a2_, a3_, a4_, a5_, a6_, a7);
		}
	};


	// 引数7個のメソッドに、
	// thisと7個の引数をbindして、
	// 引数0個の関数にする。
 template <class T, typename R, typename A1, typename A2, typename A3,
     typename A4, typename A5, typename A6, typename A7>
	class MethodBinder<R(T::*)(A1, A2, A3, A4, A5, A6, A7), 7> :
		public BaseFunctionHolder<R(*)()>{
	public:
		typedef R (T::*MethodType)(A1, A2, A3, A4, A5, A6, A7);
		typedef R (*CallFunctionType)();
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef MethodBinder<MethodType, 7> ThisType;
	private:
		MethodType method_;
		T * instance_;
		A1 a1_; A2 a2_; A3 a3_; A4 a4_; A5 a5_; A6 a6_; A7 a7_;
	public:
  MethodBinder(MethodType method, T * instance, A1 a1, A2 a2, A3 a3, A4 a4,
      A5 a5, A6 a6, A7 a7):
		method_(method),
		instance_(instance),
		a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5), a6_(a6), a7_(a7)
		{
		}
		virtual ~MethodBinder(){
		}
		virtual SuperType * Clone() const {
   return ICK_NEW(ThisType, method_, instance_, a1_, a2_, a3_, a4_, a5_, a6_,
       a7_);
		}
		virtual R operator() () {
			return (instance_->*method_)(a1_, a2_, a3_, a4_, a5_, a6_, a7_);
		}
	};


	// 引数8個のメソッドに、
	// thisと0個の引数をbindして、
	// 引数8個の関数にする。
 template <class T, typename R, typename A1, typename A2, typename A3,
     typename A4, typename A5, typename A6, typename A7, typename A8>
	class MethodBinder<R(T::*)(A1, A2, A3, A4, A5, A6, A7, A8), 0> :
		public BaseFunctionHolder<R(*)(A1, A2, A3, A4, A5, A6, A7, A8)>{
	public:
		typedef R (T::*MethodType)(A1, A2, A3, A4, A5, A6, A7, A8);
		typedef R (*CallFunctionType)(A1, A2, A3, A4, A5, A6, A7, A8);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef MethodBinder<MethodType, 0> ThisType;
	private:
		MethodType method_;
		T * instance_;

	public:
		MethodBinder(MethodType method, T * instance):
		method_(method),
		instance_(instance)
		{
		}
		virtual ~MethodBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, method_, instance_);
		}
  virtual R operator() (A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7,
      A8 a8) {
			return (instance_->*method_)(a1, a2, a3, a4, a5, a6, a7, a8);
		}
	};


	// 引数8個のメソッドに、
	// thisと1個の引数をbindして、
	// 引数7個の関数にする。
 template <class T, typename R, typename A1, typename A2, typename A3,
     typename A4, typename A5, typename A6, typename A7, typename A8>
	class MethodBinder<R(T::*)(A1, A2, A3, A4, A5, A6, A7, A8), 1> :
		public BaseFunctionHolder<R(*)(A2, A3, A4, A5, A6, A7, A8)>{
	public:
		typedef R (T::*MethodType)(A1, A2, A3, A4, A5, A6, A7, A8);
		typedef R (*CallFunctionType)(A2, A3, A4, A5, A6, A7, A8);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef MethodBinder<MethodType, 1> ThisType;
	private:
		MethodType method_;
		T * instance_;
		A1 a1_;
	public:
		MethodBinder(MethodType method, T * instance, A1 a1):
		method_(method),
		instance_(instance),
		a1_(a1)
		{
		}
		virtual ~MethodBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, method_, instance_, a1_);
		}
		virtual R operator() (A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) {
			return (instance_->*method_)(a1_, a2, a3, a4, a5, a6, a7, a8);
		}
	};


	// 引数8個のメソッドに、
	// thisと2個の引数をbindして、
	// 引数6個の関数にする。
 template <class T, typename R, typename A1, typename A2, typename A3,
     typename A4, typename A5, typename A6, typename A7, typename A8>
	class MethodBinder<R(T::*)(A1, A2, A3, A4, A5, A6, A7, A8), 2> :
		public BaseFunctionHolder<R(*)(A3, A4, A5, A6, A7, A8)>{
	public:
		typedef R (T::*MethodType)(A1, A2, A3, A4, A5, A6, A7, A8);
		typedef R (*CallFunctionType)(A3, A4, A5, A6, A7, A8);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef MethodBinder<MethodType, 2> ThisType;
	private:
		MethodType method_;
		T * instance_;
		A1 a1_; A2 a2_;
	public:
		MethodBinder(MethodType method, T * instance, A1 a1, A2 a2):
		method_(method),
		instance_(instance),
		a1_(a1), a2_(a2)
		{
		}
		virtual ~MethodBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, method_, instance_, a1_, a2_);
		}
		virtual R operator() (A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) {
			return (instance_->*method_)(a1_, a2_, a3, a4, a5, a6, a7, a8);
		}
	};


	// 引数8個のメソッドに、
	// thisと3個の引数をbindして、
	// 引数5個の関数にする。
 template <class T, typename R, typename A1, typename A2, typename A3,
     typename A4, typename A5, typename A6, typename A7, typename A8>
	class MethodBinder<R(T::*)(A1, A2, A3, A4, A5, A6, A7, A8), 3> :
		public BaseFunctionHolder<R(*)(A4, A5, A6, A7, A8)>{
	public:
		typedef R (T::*MethodType)(A1, A2, A3, A4, A5, A6, A7, A8);
		typedef R (*CallFunctionType)(A4, A5, A6, A7, A8);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef MethodBinder<MethodType, 3> ThisType;
	private:
		MethodType method_;
		T * instance_;
		A1 a1_; A2 a2_; A3 a3_;
	public:
		MethodBinder(MethodType method, T * instance, A1 a1, A2 a2, A3 a3):
		method_(method),
		instance_(instance),
		a1_(a1), a2_(a2), a3_(a3)
		{
		}
		virtual ~MethodBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, method_, instance_, a1_, a2_, a3_);
		}
		virtual R operator() (A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) {
			return (instance_->*method_)(a1_, a2_, a3_, a4, a5, a6, a7, a8);
		}
	};


	// 引数8個のメソッドに、
	// thisと4個の引数をbindして、
	// 引数4個の関数にする。
 template <class T, typename R, typename A1, typename A2, typename A3,
     typename A4, typename A5, typename A6, typename A7, typename A8>
	class MethodBinder<R(T::*)(A1, A2, A3, A4, A5, A6, A7, A8), 4> :
		public BaseFunctionHolder<R(*)(A5, A6, A7, A8)>{
	public:
		typedef R (T::*MethodType)(A1, A2, A3, A4, A5, A6, A7, A8);
		typedef R (*CallFunctionType)(A5, A6, A7, A8);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef MethodBinder<MethodType, 4> ThisType;
	private:
		MethodType method_;
		T * instance_;
		A1 a1_; A2 a2_; A3 a3_; A4 a4_;
	public:
		MethodBinder(MethodType method, T * instance, A1 a1, A2 a2, A3 a3, A4 a4):
		method_(method),
		instance_(instance),
		a1_(a1), a2_(a2), a3_(a3), a4_(a4)
		{
		}
		virtual ~MethodBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, method_, instance_, a1_, a2_, a3_, a4_);
		}
		virtual R operator() (A5 a5, A6 a6, A7 a7, A8 a8) {
			return (instance_->*method_)(a1_, a2_, a3_, a4_, a5, a6, a7, a8);
		}
	};


	// 引数8個のメソッドに、
	// thisと5個の引数をbindして、
	// 引数3個の関数にする。
 template <class T, typename R, typename A1, typename A2, typename A3,
     typename A4, typename A5, typename A6, typename A7, typename A8>
	class MethodBinder<R(T::*)(A1, A2, A3, A4, A5, A6, A7, A8), 5> :
		public BaseFunctionHolder<R(*)(A6, A7, A8)>{
	public:
		typedef R (T::*MethodType)(A1, A2, A3, A4, A5, A6, A7, A8);
		typedef R (*CallFunctionType)(A6, A7, A8);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef MethodBinder<MethodType, 5> ThisType;
	private:
		MethodType method_;
		T * instance_;
		A1 a1_; A2 a2_; A3 a3_; A4 a4_; A5 a5_;
	public:
  MethodBinder(MethodType method, T * instance, A1 a1, A2 a2, A3 a3, A4 a4,
      A5 a5):
		method_(method),
		instance_(instance),
		a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5)
		{
		}
		virtual ~MethodBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, method_, instance_, a1_, a2_, a3_, a4_, a5_);
		}
		virtual R operator() (A6 a6, A7 a7, A8 a8) {
			return (instance_->*method_)(a1_, a2_, a3_, a4_, a5_, a6, a7, a8);
		}
	};


	// 引数8個のメソッドに、
	// thisと6個の引数をbindして、
	// 引数2個の関数にする。
 template <class T, typename R, typename A1, typename A2, typename A3,
     typename A4, typename A5, typename A6, typename A7, typename A8>
	class MethodBinder<R(T::*)(A1, A2, A3, A4, A5, A6, A7, A8), 6> :
		public BaseFunctionHolder<R(*)(A7, A8)>{
	public:
		typedef R (T::*MethodType)(A1, A2, A3, A4, A5, A6, A7, A8);
		typedef R (*CallFunctionType)(A7, A8);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef MethodBinder<MethodType, 6> ThisType;
	private:
		MethodType method_;
		T * instance_;
		A1 a1_; A2 a2_; A3 a3_; A4 a4_; A5 a5_; A6 a6_;
	public:
  MethodBinder(MethodType method, T * instance, A1 a1, A2 a2, A3 a3, A4 a4,
      A5 a5, A6 a6):
		method_(method),
		instance_(instance),
		a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5), a6_(a6)
		{
		}
		virtual ~MethodBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, method_, instance_, a1_, a2_, a3_, a4_, a5_, a6_);
		}
		virtual R operator() (A7 a7, A8 a8) {
			return (instance_->*method_)(a1_, a2_, a3_, a4_, a5_, a6_, a7, a8);
		}
	};


	// 引数8個のメソッドに、
	// thisと7個の引数をbindして、
	// 引数1個の関数にする。
 template <class T, typename R, typename A1, typename A2, typename A3,
     typename A4, typename A5, typename A6, typename A7, typename A8>
	class MethodBinder<R(T::*)(A1, A2, A3, A4, A5, A6, A7, A8), 7> :
		public BaseFunctionHolder<R(*)(A8)>{
	public:
		typedef R (T::*MethodType)(A1, A2, A3, A4, A5, A6, A7, A8);
		typedef R (*CallFunctionType)(A8);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef MethodBinder<MethodType, 7> ThisType;
	private:
		MethodType method_;
		T * instance_;
		A1 a1_; A2 a2_; A3 a3_; A4 a4_; A5 a5_; A6 a6_; A7 a7_;
	public:
  MethodBinder(MethodType method, T * instance, A1 a1, A2 a2, A3 a3, A4 a4,
      A5 a5, A6 a6, A7 a7):
		method_(method),
		instance_(instance),
		a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5), a6_(a6), a7_(a7)
		{
		}
		virtual ~MethodBinder(){
		}
		virtual SuperType * Clone() const {
   return ICK_NEW(ThisType, method_, instance_, a1_, a2_, a3_, a4_, a5_, a6_,
       a7_);
		}
		virtual R operator() (A8 a8) {
			return (instance_->*method_)(a1_, a2_, a3_, a4_, a5_, a6_, a7_, a8);
		}
	};


	// 引数8個のメソッドに、
	// thisと8個の引数をbindして、
	// 引数0個の関数にする。
 template <class T, typename R, typename A1, typename A2, typename A3,
     typename A4, typename A5, typename A6, typename A7, typename A8>
	class MethodBinder<R(T::*)(A1, A2, A3, A4, A5, A6, A7, A8), 8> :
		public BaseFunctionHolder<R(*)()>{
	public:
		typedef R (T::*MethodType)(A1, A2, A3, A4, A5, A6, A7, A8);
		typedef R (*CallFunctionType)();
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef MethodBinder<MethodType, 8> ThisType;
	private:
		MethodType method_;
		T * instance_;
		A1 a1_; A2 a2_; A3 a3_; A4 a4_; A5 a5_; A6 a6_; A7 a7_; A8 a8_;
	public:
  MethodBinder(MethodType method, T * instance, A1 a1, A2 a2, A3 a3, A4 a4,
      A5 a5, A6 a6, A7 a7, A8 a8):
		method_(method),
		instance_(instance),
		a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5), a6_(a6), a7_(a7), a8_(a8)
		{
		}
		virtual ~MethodBinder(){
		}
		virtual SuperType * Clone() const {
   return ICK_NEW(ThisType, method_, instance_, a1_, a2_, a3_, a4_, a5_, a6_,
       a7_, a8_);
		}
		virtual R operator() () {
			return (instance_->*method_)(a1_, a2_, a3_, a4_, a5_, a6_, a7_, a8_);
		}
	};


}
