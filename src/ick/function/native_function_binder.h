// This file was GENERATED by command:
//     pump.py native_function_binder.h.pump
// DO NOT EDIT BY HAND!!!

#pragma once

#include "../base/memory.h"

#include "base_function_holder.h"

namespace ick {
	template <typename F> class BaseFunctionHolder;
	template <typename F, int N> class NativeFunctionBinder;

	// 引数0個の関数に、0個の引数をbindして、
	// 引数0個の関数にする。
	template <typename R>
	class NativeFunctionBinder<R(*)(), 0> :
		public BaseFunctionHolder<R(*)()>{
	public:
		typedef R (*FunctionType)();
		typedef R (*CallFunctionType)();
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef NativeFunctionBinder<FunctionType, 0> ThisType;
	private:
		FunctionType native_function_;

	public:
		NativeFunctionBinder(FunctionType native_function):
		native_function_(native_function)
		{
		}
		virtual ~NativeFunctionBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, native_function_);
		}
		virtual R operator() () {
			return (*native_function_)();
		}
	};


	// 引数1個の関数に、0個の引数をbindして、
	// 引数1個の関数にする。
	template <typename R, typename A1>
	class NativeFunctionBinder<R(*)(A1), 0> :
		public BaseFunctionHolder<R(*)(A1)>{
	public:
		typedef R (*FunctionType)(A1);
		typedef R (*CallFunctionType)(A1);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef NativeFunctionBinder<FunctionType, 0> ThisType;
	private:
		FunctionType native_function_;

	public:
		NativeFunctionBinder(FunctionType native_function):
		native_function_(native_function)
		{
		}
		virtual ~NativeFunctionBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, native_function_);
		}
		virtual R operator() (A1 a1) {
			return (*native_function_)(a1);
		}
	};


	// 引数1個の関数に、1個の引数をbindして、
	// 引数0個の関数にする。
	template <typename R, typename A1>
	class NativeFunctionBinder<R(*)(A1), 1> :
		public BaseFunctionHolder<R(*)()>{
	public:
		typedef R (*FunctionType)(A1);
		typedef R (*CallFunctionType)();
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef NativeFunctionBinder<FunctionType, 1> ThisType;
	private:
		FunctionType native_function_;
		A1 a1_;
	public:
		NativeFunctionBinder(FunctionType native_function, A1 a1):
		native_function_(native_function),
		a1_(a1)
		{
		}
		virtual ~NativeFunctionBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, native_function_, a1_);
		}
		virtual R operator() () {
			return (*native_function_)(a1_);
		}
	};


	// 引数2個の関数に、0個の引数をbindして、
	// 引数2個の関数にする。
	template <typename R, typename A1, typename A2>
	class NativeFunctionBinder<R(*)(A1, A2), 0> :
		public BaseFunctionHolder<R(*)(A1, A2)>{
	public:
		typedef R (*FunctionType)(A1, A2);
		typedef R (*CallFunctionType)(A1, A2);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef NativeFunctionBinder<FunctionType, 0> ThisType;
	private:
		FunctionType native_function_;

	public:
		NativeFunctionBinder(FunctionType native_function):
		native_function_(native_function)
		{
		}
		virtual ~NativeFunctionBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, native_function_);
		}
		virtual R operator() (A1 a1, A2 a2) {
			return (*native_function_)(a1, a2);
		}
	};


	// 引数2個の関数に、1個の引数をbindして、
	// 引数1個の関数にする。
	template <typename R, typename A1, typename A2>
	class NativeFunctionBinder<R(*)(A1, A2), 1> :
		public BaseFunctionHolder<R(*)(A2)>{
	public:
		typedef R (*FunctionType)(A1, A2);
		typedef R (*CallFunctionType)(A2);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef NativeFunctionBinder<FunctionType, 1> ThisType;
	private:
		FunctionType native_function_;
		A1 a1_;
	public:
		NativeFunctionBinder(FunctionType native_function, A1 a1):
		native_function_(native_function),
		a1_(a1)
		{
		}
		virtual ~NativeFunctionBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, native_function_, a1_);
		}
		virtual R operator() (A2 a2) {
			return (*native_function_)(a1_, a2);
		}
	};


	// 引数2個の関数に、2個の引数をbindして、
	// 引数0個の関数にする。
	template <typename R, typename A1, typename A2>
	class NativeFunctionBinder<R(*)(A1, A2), 2> :
		public BaseFunctionHolder<R(*)()>{
	public:
		typedef R (*FunctionType)(A1, A2);
		typedef R (*CallFunctionType)();
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef NativeFunctionBinder<FunctionType, 2> ThisType;
	private:
		FunctionType native_function_;
		A1 a1_; A2 a2_;
	public:
		NativeFunctionBinder(FunctionType native_function, A1 a1, A2 a2):
		native_function_(native_function),
		a1_(a1), a2_(a2)
		{
		}
		virtual ~NativeFunctionBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, native_function_, a1_, a2_);
		}
		virtual R operator() () {
			return (*native_function_)(a1_, a2_);
		}
	};


	// 引数3個の関数に、0個の引数をbindして、
	// 引数3個の関数にする。
	template <typename R, typename A1, typename A2, typename A3>
	class NativeFunctionBinder<R(*)(A1, A2, A3), 0> :
		public BaseFunctionHolder<R(*)(A1, A2, A3)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3);
		typedef R (*CallFunctionType)(A1, A2, A3);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef NativeFunctionBinder<FunctionType, 0> ThisType;
	private:
		FunctionType native_function_;

	public:
		NativeFunctionBinder(FunctionType native_function):
		native_function_(native_function)
		{
		}
		virtual ~NativeFunctionBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, native_function_);
		}
		virtual R operator() (A1 a1, A2 a2, A3 a3) {
			return (*native_function_)(a1, a2, a3);
		}
	};


	// 引数3個の関数に、1個の引数をbindして、
	// 引数2個の関数にする。
	template <typename R, typename A1, typename A2, typename A3>
	class NativeFunctionBinder<R(*)(A1, A2, A3), 1> :
		public BaseFunctionHolder<R(*)(A2, A3)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3);
		typedef R (*CallFunctionType)(A2, A3);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef NativeFunctionBinder<FunctionType, 1> ThisType;
	private:
		FunctionType native_function_;
		A1 a1_;
	public:
		NativeFunctionBinder(FunctionType native_function, A1 a1):
		native_function_(native_function),
		a1_(a1)
		{
		}
		virtual ~NativeFunctionBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, native_function_, a1_);
		}
		virtual R operator() (A2 a2, A3 a3) {
			return (*native_function_)(a1_, a2, a3);
		}
	};


	// 引数3個の関数に、2個の引数をbindして、
	// 引数1個の関数にする。
	template <typename R, typename A1, typename A2, typename A3>
	class NativeFunctionBinder<R(*)(A1, A2, A3), 2> :
		public BaseFunctionHolder<R(*)(A3)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3);
		typedef R (*CallFunctionType)(A3);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef NativeFunctionBinder<FunctionType, 2> ThisType;
	private:
		FunctionType native_function_;
		A1 a1_; A2 a2_;
	public:
		NativeFunctionBinder(FunctionType native_function, A1 a1, A2 a2):
		native_function_(native_function),
		a1_(a1), a2_(a2)
		{
		}
		virtual ~NativeFunctionBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, native_function_, a1_, a2_);
		}
		virtual R operator() (A3 a3) {
			return (*native_function_)(a1_, a2_, a3);
		}
	};


	// 引数3個の関数に、3個の引数をbindして、
	// 引数0個の関数にする。
	template <typename R, typename A1, typename A2, typename A3>
	class NativeFunctionBinder<R(*)(A1, A2, A3), 3> :
		public BaseFunctionHolder<R(*)()>{
	public:
		typedef R (*FunctionType)(A1, A2, A3);
		typedef R (*CallFunctionType)();
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef NativeFunctionBinder<FunctionType, 3> ThisType;
	private:
		FunctionType native_function_;
		A1 a1_; A2 a2_; A3 a3_;
	public:
		NativeFunctionBinder(FunctionType native_function, A1 a1, A2 a2, A3 a3):
		native_function_(native_function),
		a1_(a1), a2_(a2), a3_(a3)
		{
		}
		virtual ~NativeFunctionBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, native_function_, a1_, a2_, a3_);
		}
		virtual R operator() () {
			return (*native_function_)(a1_, a2_, a3_);
		}
	};


	// 引数4個の関数に、0個の引数をbindして、
	// 引数4個の関数にする。
	template <typename R, typename A1, typename A2, typename A3, typename A4>
	class NativeFunctionBinder<R(*)(A1, A2, A3, A4), 0> :
		public BaseFunctionHolder<R(*)(A1, A2, A3, A4)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4);
		typedef R (*CallFunctionType)(A1, A2, A3, A4);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef NativeFunctionBinder<FunctionType, 0> ThisType;
	private:
		FunctionType native_function_;

	public:
		NativeFunctionBinder(FunctionType native_function):
		native_function_(native_function)
		{
		}
		virtual ~NativeFunctionBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, native_function_);
		}
		virtual R operator() (A1 a1, A2 a2, A3 a3, A4 a4) {
			return (*native_function_)(a1, a2, a3, a4);
		}
	};


	// 引数4個の関数に、1個の引数をbindして、
	// 引数3個の関数にする。
	template <typename R, typename A1, typename A2, typename A3, typename A4>
	class NativeFunctionBinder<R(*)(A1, A2, A3, A4), 1> :
		public BaseFunctionHolder<R(*)(A2, A3, A4)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4);
		typedef R (*CallFunctionType)(A2, A3, A4);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef NativeFunctionBinder<FunctionType, 1> ThisType;
	private:
		FunctionType native_function_;
		A1 a1_;
	public:
		NativeFunctionBinder(FunctionType native_function, A1 a1):
		native_function_(native_function),
		a1_(a1)
		{
		}
		virtual ~NativeFunctionBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, native_function_, a1_);
		}
		virtual R operator() (A2 a2, A3 a3, A4 a4) {
			return (*native_function_)(a1_, a2, a3, a4);
		}
	};


	// 引数4個の関数に、2個の引数をbindして、
	// 引数2個の関数にする。
	template <typename R, typename A1, typename A2, typename A3, typename A4>
	class NativeFunctionBinder<R(*)(A1, A2, A3, A4), 2> :
		public BaseFunctionHolder<R(*)(A3, A4)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4);
		typedef R (*CallFunctionType)(A3, A4);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef NativeFunctionBinder<FunctionType, 2> ThisType;
	private:
		FunctionType native_function_;
		A1 a1_; A2 a2_;
	public:
		NativeFunctionBinder(FunctionType native_function, A1 a1, A2 a2):
		native_function_(native_function),
		a1_(a1), a2_(a2)
		{
		}
		virtual ~NativeFunctionBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, native_function_, a1_, a2_);
		}
		virtual R operator() (A3 a3, A4 a4) {
			return (*native_function_)(a1_, a2_, a3, a4);
		}
	};


	// 引数4個の関数に、3個の引数をbindして、
	// 引数1個の関数にする。
	template <typename R, typename A1, typename A2, typename A3, typename A4>
	class NativeFunctionBinder<R(*)(A1, A2, A3, A4), 3> :
		public BaseFunctionHolder<R(*)(A4)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4);
		typedef R (*CallFunctionType)(A4);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef NativeFunctionBinder<FunctionType, 3> ThisType;
	private:
		FunctionType native_function_;
		A1 a1_; A2 a2_; A3 a3_;
	public:
		NativeFunctionBinder(FunctionType native_function, A1 a1, A2 a2, A3 a3):
		native_function_(native_function),
		a1_(a1), a2_(a2), a3_(a3)
		{
		}
		virtual ~NativeFunctionBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, native_function_, a1_, a2_, a3_);
		}
		virtual R operator() (A4 a4) {
			return (*native_function_)(a1_, a2_, a3_, a4);
		}
	};


	// 引数4個の関数に、4個の引数をbindして、
	// 引数0個の関数にする。
	template <typename R, typename A1, typename A2, typename A3, typename A4>
	class NativeFunctionBinder<R(*)(A1, A2, A3, A4), 4> :
		public BaseFunctionHolder<R(*)()>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4);
		typedef R (*CallFunctionType)();
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef NativeFunctionBinder<FunctionType, 4> ThisType;
	private:
		FunctionType native_function_;
		A1 a1_; A2 a2_; A3 a3_; A4 a4_;
	public:
  NativeFunctionBinder(FunctionType native_function, A1 a1, A2 a2, A3 a3,
      A4 a4):
		native_function_(native_function),
		a1_(a1), a2_(a2), a3_(a3), a4_(a4)
		{
		}
		virtual ~NativeFunctionBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, native_function_, a1_, a2_, a3_, a4_);
		}
		virtual R operator() () {
			return (*native_function_)(a1_, a2_, a3_, a4_);
		}
	};


	// 引数5個の関数に、0個の引数をbindして、
	// 引数5個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5>
	class NativeFunctionBinder<R(*)(A1, A2, A3, A4, A5), 0> :
		public BaseFunctionHolder<R(*)(A1, A2, A3, A4, A5)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5);
		typedef R (*CallFunctionType)(A1, A2, A3, A4, A5);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef NativeFunctionBinder<FunctionType, 0> ThisType;
	private:
		FunctionType native_function_;

	public:
		NativeFunctionBinder(FunctionType native_function):
		native_function_(native_function)
		{
		}
		virtual ~NativeFunctionBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, native_function_);
		}
		virtual R operator() (A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) {
			return (*native_function_)(a1, a2, a3, a4, a5);
		}
	};


	// 引数5個の関数に、1個の引数をbindして、
	// 引数4個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5>
	class NativeFunctionBinder<R(*)(A1, A2, A3, A4, A5), 1> :
		public BaseFunctionHolder<R(*)(A2, A3, A4, A5)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5);
		typedef R (*CallFunctionType)(A2, A3, A4, A5);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef NativeFunctionBinder<FunctionType, 1> ThisType;
	private:
		FunctionType native_function_;
		A1 a1_;
	public:
		NativeFunctionBinder(FunctionType native_function, A1 a1):
		native_function_(native_function),
		a1_(a1)
		{
		}
		virtual ~NativeFunctionBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, native_function_, a1_);
		}
		virtual R operator() (A2 a2, A3 a3, A4 a4, A5 a5) {
			return (*native_function_)(a1_, a2, a3, a4, a5);
		}
	};


	// 引数5個の関数に、2個の引数をbindして、
	// 引数3個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5>
	class NativeFunctionBinder<R(*)(A1, A2, A3, A4, A5), 2> :
		public BaseFunctionHolder<R(*)(A3, A4, A5)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5);
		typedef R (*CallFunctionType)(A3, A4, A5);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef NativeFunctionBinder<FunctionType, 2> ThisType;
	private:
		FunctionType native_function_;
		A1 a1_; A2 a2_;
	public:
		NativeFunctionBinder(FunctionType native_function, A1 a1, A2 a2):
		native_function_(native_function),
		a1_(a1), a2_(a2)
		{
		}
		virtual ~NativeFunctionBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, native_function_, a1_, a2_);
		}
		virtual R operator() (A3 a3, A4 a4, A5 a5) {
			return (*native_function_)(a1_, a2_, a3, a4, a5);
		}
	};


	// 引数5個の関数に、3個の引数をbindして、
	// 引数2個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5>
	class NativeFunctionBinder<R(*)(A1, A2, A3, A4, A5), 3> :
		public BaseFunctionHolder<R(*)(A4, A5)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5);
		typedef R (*CallFunctionType)(A4, A5);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef NativeFunctionBinder<FunctionType, 3> ThisType;
	private:
		FunctionType native_function_;
		A1 a1_; A2 a2_; A3 a3_;
	public:
		NativeFunctionBinder(FunctionType native_function, A1 a1, A2 a2, A3 a3):
		native_function_(native_function),
		a1_(a1), a2_(a2), a3_(a3)
		{
		}
		virtual ~NativeFunctionBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, native_function_, a1_, a2_, a3_);
		}
		virtual R operator() (A4 a4, A5 a5) {
			return (*native_function_)(a1_, a2_, a3_, a4, a5);
		}
	};


	// 引数5個の関数に、4個の引数をbindして、
	// 引数1個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5>
	class NativeFunctionBinder<R(*)(A1, A2, A3, A4, A5), 4> :
		public BaseFunctionHolder<R(*)(A5)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5);
		typedef R (*CallFunctionType)(A5);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef NativeFunctionBinder<FunctionType, 4> ThisType;
	private:
		FunctionType native_function_;
		A1 a1_; A2 a2_; A3 a3_; A4 a4_;
	public:
  NativeFunctionBinder(FunctionType native_function, A1 a1, A2 a2, A3 a3,
      A4 a4):
		native_function_(native_function),
		a1_(a1), a2_(a2), a3_(a3), a4_(a4)
		{
		}
		virtual ~NativeFunctionBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, native_function_, a1_, a2_, a3_, a4_);
		}
		virtual R operator() (A5 a5) {
			return (*native_function_)(a1_, a2_, a3_, a4_, a5);
		}
	};


	// 引数5個の関数に、5個の引数をbindして、
	// 引数0個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5>
	class NativeFunctionBinder<R(*)(A1, A2, A3, A4, A5), 5> :
		public BaseFunctionHolder<R(*)()>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5);
		typedef R (*CallFunctionType)();
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef NativeFunctionBinder<FunctionType, 5> ThisType;
	private:
		FunctionType native_function_;
		A1 a1_; A2 a2_; A3 a3_; A4 a4_; A5 a5_;
	public:
  NativeFunctionBinder(FunctionType native_function, A1 a1, A2 a2, A3 a3,
      A4 a4, A5 a5):
		native_function_(native_function),
		a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5)
		{
		}
		virtual ~NativeFunctionBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, native_function_, a1_, a2_, a3_, a4_, a5_);
		}
		virtual R operator() () {
			return (*native_function_)(a1_, a2_, a3_, a4_, a5_);
		}
	};


	// 引数6個の関数に、0個の引数をbindして、
	// 引数6個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5, typename A6>
	class NativeFunctionBinder<R(*)(A1, A2, A3, A4, A5, A6), 0> :
		public BaseFunctionHolder<R(*)(A1, A2, A3, A4, A5, A6)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5, A6);
		typedef R (*CallFunctionType)(A1, A2, A3, A4, A5, A6);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef NativeFunctionBinder<FunctionType, 0> ThisType;
	private:
		FunctionType native_function_;

	public:
		NativeFunctionBinder(FunctionType native_function):
		native_function_(native_function)
		{
		}
		virtual ~NativeFunctionBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, native_function_);
		}
		virtual R operator() (A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) {
			return (*native_function_)(a1, a2, a3, a4, a5, a6);
		}
	};


	// 引数6個の関数に、1個の引数をbindして、
	// 引数5個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5, typename A6>
	class NativeFunctionBinder<R(*)(A1, A2, A3, A4, A5, A6), 1> :
		public BaseFunctionHolder<R(*)(A2, A3, A4, A5, A6)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5, A6);
		typedef R (*CallFunctionType)(A2, A3, A4, A5, A6);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef NativeFunctionBinder<FunctionType, 1> ThisType;
	private:
		FunctionType native_function_;
		A1 a1_;
	public:
		NativeFunctionBinder(FunctionType native_function, A1 a1):
		native_function_(native_function),
		a1_(a1)
		{
		}
		virtual ~NativeFunctionBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, native_function_, a1_);
		}
		virtual R operator() (A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) {
			return (*native_function_)(a1_, a2, a3, a4, a5, a6);
		}
	};


	// 引数6個の関数に、2個の引数をbindして、
	// 引数4個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5, typename A6>
	class NativeFunctionBinder<R(*)(A1, A2, A3, A4, A5, A6), 2> :
		public BaseFunctionHolder<R(*)(A3, A4, A5, A6)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5, A6);
		typedef R (*CallFunctionType)(A3, A4, A5, A6);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef NativeFunctionBinder<FunctionType, 2> ThisType;
	private:
		FunctionType native_function_;
		A1 a1_; A2 a2_;
	public:
		NativeFunctionBinder(FunctionType native_function, A1 a1, A2 a2):
		native_function_(native_function),
		a1_(a1), a2_(a2)
		{
		}
		virtual ~NativeFunctionBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, native_function_, a1_, a2_);
		}
		virtual R operator() (A3 a3, A4 a4, A5 a5, A6 a6) {
			return (*native_function_)(a1_, a2_, a3, a4, a5, a6);
		}
	};


	// 引数6個の関数に、3個の引数をbindして、
	// 引数3個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5, typename A6>
	class NativeFunctionBinder<R(*)(A1, A2, A3, A4, A5, A6), 3> :
		public BaseFunctionHolder<R(*)(A4, A5, A6)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5, A6);
		typedef R (*CallFunctionType)(A4, A5, A6);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef NativeFunctionBinder<FunctionType, 3> ThisType;
	private:
		FunctionType native_function_;
		A1 a1_; A2 a2_; A3 a3_;
	public:
		NativeFunctionBinder(FunctionType native_function, A1 a1, A2 a2, A3 a3):
		native_function_(native_function),
		a1_(a1), a2_(a2), a3_(a3)
		{
		}
		virtual ~NativeFunctionBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, native_function_, a1_, a2_, a3_);
		}
		virtual R operator() (A4 a4, A5 a5, A6 a6) {
			return (*native_function_)(a1_, a2_, a3_, a4, a5, a6);
		}
	};


	// 引数6個の関数に、4個の引数をbindして、
	// 引数2個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5, typename A6>
	class NativeFunctionBinder<R(*)(A1, A2, A3, A4, A5, A6), 4> :
		public BaseFunctionHolder<R(*)(A5, A6)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5, A6);
		typedef R (*CallFunctionType)(A5, A6);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef NativeFunctionBinder<FunctionType, 4> ThisType;
	private:
		FunctionType native_function_;
		A1 a1_; A2 a2_; A3 a3_; A4 a4_;
	public:
  NativeFunctionBinder(FunctionType native_function, A1 a1, A2 a2, A3 a3,
      A4 a4):
		native_function_(native_function),
		a1_(a1), a2_(a2), a3_(a3), a4_(a4)
		{
		}
		virtual ~NativeFunctionBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, native_function_, a1_, a2_, a3_, a4_);
		}
		virtual R operator() (A5 a5, A6 a6) {
			return (*native_function_)(a1_, a2_, a3_, a4_, a5, a6);
		}
	};


	// 引数6個の関数に、5個の引数をbindして、
	// 引数1個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5, typename A6>
	class NativeFunctionBinder<R(*)(A1, A2, A3, A4, A5, A6), 5> :
		public BaseFunctionHolder<R(*)(A6)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5, A6);
		typedef R (*CallFunctionType)(A6);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef NativeFunctionBinder<FunctionType, 5> ThisType;
	private:
		FunctionType native_function_;
		A1 a1_; A2 a2_; A3 a3_; A4 a4_; A5 a5_;
	public:
  NativeFunctionBinder(FunctionType native_function, A1 a1, A2 a2, A3 a3,
      A4 a4, A5 a5):
		native_function_(native_function),
		a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5)
		{
		}
		virtual ~NativeFunctionBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, native_function_, a1_, a2_, a3_, a4_, a5_);
		}
		virtual R operator() (A6 a6) {
			return (*native_function_)(a1_, a2_, a3_, a4_, a5_, a6);
		}
	};


	// 引数6個の関数に、6個の引数をbindして、
	// 引数0個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5, typename A6>
	class NativeFunctionBinder<R(*)(A1, A2, A3, A4, A5, A6), 6> :
		public BaseFunctionHolder<R(*)()>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5, A6);
		typedef R (*CallFunctionType)();
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef NativeFunctionBinder<FunctionType, 6> ThisType;
	private:
		FunctionType native_function_;
		A1 a1_; A2 a2_; A3 a3_; A4 a4_; A5 a5_; A6 a6_;
	public:
  NativeFunctionBinder(FunctionType native_function, A1 a1, A2 a2, A3 a3,
      A4 a4, A5 a5, A6 a6):
		native_function_(native_function),
		a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5), a6_(a6)
		{
		}
		virtual ~NativeFunctionBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, native_function_, a1_, a2_, a3_, a4_, a5_, a6_);
		}
		virtual R operator() () {
			return (*native_function_)(a1_, a2_, a3_, a4_, a5_, a6_);
		}
	};


	// 引数7個の関数に、0個の引数をbindして、
	// 引数7個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5, typename A6, typename A7>
	class NativeFunctionBinder<R(*)(A1, A2, A3, A4, A5, A6, A7), 0> :
		public BaseFunctionHolder<R(*)(A1, A2, A3, A4, A5, A6, A7)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5, A6, A7);
		typedef R (*CallFunctionType)(A1, A2, A3, A4, A5, A6, A7);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef NativeFunctionBinder<FunctionType, 0> ThisType;
	private:
		FunctionType native_function_;

	public:
		NativeFunctionBinder(FunctionType native_function):
		native_function_(native_function)
		{
		}
		virtual ~NativeFunctionBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, native_function_);
		}
		virtual R operator() (A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) {
			return (*native_function_)(a1, a2, a3, a4, a5, a6, a7);
		}
	};


	// 引数7個の関数に、1個の引数をbindして、
	// 引数6個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5, typename A6, typename A7>
	class NativeFunctionBinder<R(*)(A1, A2, A3, A4, A5, A6, A7), 1> :
		public BaseFunctionHolder<R(*)(A2, A3, A4, A5, A6, A7)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5, A6, A7);
		typedef R (*CallFunctionType)(A2, A3, A4, A5, A6, A7);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef NativeFunctionBinder<FunctionType, 1> ThisType;
	private:
		FunctionType native_function_;
		A1 a1_;
	public:
		NativeFunctionBinder(FunctionType native_function, A1 a1):
		native_function_(native_function),
		a1_(a1)
		{
		}
		virtual ~NativeFunctionBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, native_function_, a1_);
		}
		virtual R operator() (A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) {
			return (*native_function_)(a1_, a2, a3, a4, a5, a6, a7);
		}
	};


	// 引数7個の関数に、2個の引数をbindして、
	// 引数5個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5, typename A6, typename A7>
	class NativeFunctionBinder<R(*)(A1, A2, A3, A4, A5, A6, A7), 2> :
		public BaseFunctionHolder<R(*)(A3, A4, A5, A6, A7)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5, A6, A7);
		typedef R (*CallFunctionType)(A3, A4, A5, A6, A7);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef NativeFunctionBinder<FunctionType, 2> ThisType;
	private:
		FunctionType native_function_;
		A1 a1_; A2 a2_;
	public:
		NativeFunctionBinder(FunctionType native_function, A1 a1, A2 a2):
		native_function_(native_function),
		a1_(a1), a2_(a2)
		{
		}
		virtual ~NativeFunctionBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, native_function_, a1_, a2_);
		}
		virtual R operator() (A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) {
			return (*native_function_)(a1_, a2_, a3, a4, a5, a6, a7);
		}
	};


	// 引数7個の関数に、3個の引数をbindして、
	// 引数4個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5, typename A6, typename A7>
	class NativeFunctionBinder<R(*)(A1, A2, A3, A4, A5, A6, A7), 3> :
		public BaseFunctionHolder<R(*)(A4, A5, A6, A7)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5, A6, A7);
		typedef R (*CallFunctionType)(A4, A5, A6, A7);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef NativeFunctionBinder<FunctionType, 3> ThisType;
	private:
		FunctionType native_function_;
		A1 a1_; A2 a2_; A3 a3_;
	public:
		NativeFunctionBinder(FunctionType native_function, A1 a1, A2 a2, A3 a3):
		native_function_(native_function),
		a1_(a1), a2_(a2), a3_(a3)
		{
		}
		virtual ~NativeFunctionBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, native_function_, a1_, a2_, a3_);
		}
		virtual R operator() (A4 a4, A5 a5, A6 a6, A7 a7) {
			return (*native_function_)(a1_, a2_, a3_, a4, a5, a6, a7);
		}
	};


	// 引数7個の関数に、4個の引数をbindして、
	// 引数3個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5, typename A6, typename A7>
	class NativeFunctionBinder<R(*)(A1, A2, A3, A4, A5, A6, A7), 4> :
		public BaseFunctionHolder<R(*)(A5, A6, A7)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5, A6, A7);
		typedef R (*CallFunctionType)(A5, A6, A7);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef NativeFunctionBinder<FunctionType, 4> ThisType;
	private:
		FunctionType native_function_;
		A1 a1_; A2 a2_; A3 a3_; A4 a4_;
	public:
  NativeFunctionBinder(FunctionType native_function, A1 a1, A2 a2, A3 a3,
      A4 a4):
		native_function_(native_function),
		a1_(a1), a2_(a2), a3_(a3), a4_(a4)
		{
		}
		virtual ~NativeFunctionBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, native_function_, a1_, a2_, a3_, a4_);
		}
		virtual R operator() (A5 a5, A6 a6, A7 a7) {
			return (*native_function_)(a1_, a2_, a3_, a4_, a5, a6, a7);
		}
	};


	// 引数7個の関数に、5個の引数をbindして、
	// 引数2個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5, typename A6, typename A7>
	class NativeFunctionBinder<R(*)(A1, A2, A3, A4, A5, A6, A7), 5> :
		public BaseFunctionHolder<R(*)(A6, A7)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5, A6, A7);
		typedef R (*CallFunctionType)(A6, A7);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef NativeFunctionBinder<FunctionType, 5> ThisType;
	private:
		FunctionType native_function_;
		A1 a1_; A2 a2_; A3 a3_; A4 a4_; A5 a5_;
	public:
  NativeFunctionBinder(FunctionType native_function, A1 a1, A2 a2, A3 a3,
      A4 a4, A5 a5):
		native_function_(native_function),
		a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5)
		{
		}
		virtual ~NativeFunctionBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, native_function_, a1_, a2_, a3_, a4_, a5_);
		}
		virtual R operator() (A6 a6, A7 a7) {
			return (*native_function_)(a1_, a2_, a3_, a4_, a5_, a6, a7);
		}
	};


	// 引数7個の関数に、6個の引数をbindして、
	// 引数1個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5, typename A6, typename A7>
	class NativeFunctionBinder<R(*)(A1, A2, A3, A4, A5, A6, A7), 6> :
		public BaseFunctionHolder<R(*)(A7)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5, A6, A7);
		typedef R (*CallFunctionType)(A7);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef NativeFunctionBinder<FunctionType, 6> ThisType;
	private:
		FunctionType native_function_;
		A1 a1_; A2 a2_; A3 a3_; A4 a4_; A5 a5_; A6 a6_;
	public:
  NativeFunctionBinder(FunctionType native_function, A1 a1, A2 a2, A3 a3,
      A4 a4, A5 a5, A6 a6):
		native_function_(native_function),
		a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5), a6_(a6)
		{
		}
		virtual ~NativeFunctionBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, native_function_, a1_, a2_, a3_, a4_, a5_, a6_);
		}
		virtual R operator() (A7 a7) {
			return (*native_function_)(a1_, a2_, a3_, a4_, a5_, a6_, a7);
		}
	};


	// 引数7個の関数に、7個の引数をbindして、
	// 引数0個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5, typename A6, typename A7>
	class NativeFunctionBinder<R(*)(A1, A2, A3, A4, A5, A6, A7), 7> :
		public BaseFunctionHolder<R(*)()>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5, A6, A7);
		typedef R (*CallFunctionType)();
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef NativeFunctionBinder<FunctionType, 7> ThisType;
	private:
		FunctionType native_function_;
		A1 a1_; A2 a2_; A3 a3_; A4 a4_; A5 a5_; A6 a6_; A7 a7_;
	public:
  NativeFunctionBinder(FunctionType native_function, A1 a1, A2 a2, A3 a3,
      A4 a4, A5 a5, A6 a6, A7 a7):
		native_function_(native_function),
		a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5), a6_(a6), a7_(a7)
		{
		}
		virtual ~NativeFunctionBinder(){
		}
		virtual SuperType * Clone() const {
   return ICK_NEW(ThisType, native_function_, a1_, a2_, a3_, a4_, a5_, a6_,
       a7_);
		}
		virtual R operator() () {
			return (*native_function_)(a1_, a2_, a3_, a4_, a5_, a6_, a7_);
		}
	};


	// 引数8個の関数に、0個の引数をbindして、
	// 引数8個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5, typename A6, typename A7, typename A8>
	class NativeFunctionBinder<R(*)(A1, A2, A3, A4, A5, A6, A7, A8), 0> :
		public BaseFunctionHolder<R(*)(A1, A2, A3, A4, A5, A6, A7, A8)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5, A6, A7, A8);
		typedef R (*CallFunctionType)(A1, A2, A3, A4, A5, A6, A7, A8);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef NativeFunctionBinder<FunctionType, 0> ThisType;
	private:
		FunctionType native_function_;

	public:
		NativeFunctionBinder(FunctionType native_function):
		native_function_(native_function)
		{
		}
		virtual ~NativeFunctionBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, native_function_);
		}
  virtual R operator() (A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7,
      A8 a8) {
			return (*native_function_)(a1, a2, a3, a4, a5, a6, a7, a8);
		}
	};


	// 引数8個の関数に、1個の引数をbindして、
	// 引数7個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5, typename A6, typename A7, typename A8>
	class NativeFunctionBinder<R(*)(A1, A2, A3, A4, A5, A6, A7, A8), 1> :
		public BaseFunctionHolder<R(*)(A2, A3, A4, A5, A6, A7, A8)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5, A6, A7, A8);
		typedef R (*CallFunctionType)(A2, A3, A4, A5, A6, A7, A8);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef NativeFunctionBinder<FunctionType, 1> ThisType;
	private:
		FunctionType native_function_;
		A1 a1_;
	public:
		NativeFunctionBinder(FunctionType native_function, A1 a1):
		native_function_(native_function),
		a1_(a1)
		{
		}
		virtual ~NativeFunctionBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, native_function_, a1_);
		}
		virtual R operator() (A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) {
			return (*native_function_)(a1_, a2, a3, a4, a5, a6, a7, a8);
		}
	};


	// 引数8個の関数に、2個の引数をbindして、
	// 引数6個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5, typename A6, typename A7, typename A8>
	class NativeFunctionBinder<R(*)(A1, A2, A3, A4, A5, A6, A7, A8), 2> :
		public BaseFunctionHolder<R(*)(A3, A4, A5, A6, A7, A8)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5, A6, A7, A8);
		typedef R (*CallFunctionType)(A3, A4, A5, A6, A7, A8);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef NativeFunctionBinder<FunctionType, 2> ThisType;
	private:
		FunctionType native_function_;
		A1 a1_; A2 a2_;
	public:
		NativeFunctionBinder(FunctionType native_function, A1 a1, A2 a2):
		native_function_(native_function),
		a1_(a1), a2_(a2)
		{
		}
		virtual ~NativeFunctionBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, native_function_, a1_, a2_);
		}
		virtual R operator() (A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) {
			return (*native_function_)(a1_, a2_, a3, a4, a5, a6, a7, a8);
		}
	};


	// 引数8個の関数に、3個の引数をbindして、
	// 引数5個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5, typename A6, typename A7, typename A8>
	class NativeFunctionBinder<R(*)(A1, A2, A3, A4, A5, A6, A7, A8), 3> :
		public BaseFunctionHolder<R(*)(A4, A5, A6, A7, A8)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5, A6, A7, A8);
		typedef R (*CallFunctionType)(A4, A5, A6, A7, A8);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef NativeFunctionBinder<FunctionType, 3> ThisType;
	private:
		FunctionType native_function_;
		A1 a1_; A2 a2_; A3 a3_;
	public:
		NativeFunctionBinder(FunctionType native_function, A1 a1, A2 a2, A3 a3):
		native_function_(native_function),
		a1_(a1), a2_(a2), a3_(a3)
		{
		}
		virtual ~NativeFunctionBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, native_function_, a1_, a2_, a3_);
		}
		virtual R operator() (A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) {
			return (*native_function_)(a1_, a2_, a3_, a4, a5, a6, a7, a8);
		}
	};


	// 引数8個の関数に、4個の引数をbindして、
	// 引数4個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5, typename A6, typename A7, typename A8>
	class NativeFunctionBinder<R(*)(A1, A2, A3, A4, A5, A6, A7, A8), 4> :
		public BaseFunctionHolder<R(*)(A5, A6, A7, A8)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5, A6, A7, A8);
		typedef R (*CallFunctionType)(A5, A6, A7, A8);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef NativeFunctionBinder<FunctionType, 4> ThisType;
	private:
		FunctionType native_function_;
		A1 a1_; A2 a2_; A3 a3_; A4 a4_;
	public:
  NativeFunctionBinder(FunctionType native_function, A1 a1, A2 a2, A3 a3,
      A4 a4):
		native_function_(native_function),
		a1_(a1), a2_(a2), a3_(a3), a4_(a4)
		{
		}
		virtual ~NativeFunctionBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, native_function_, a1_, a2_, a3_, a4_);
		}
		virtual R operator() (A5 a5, A6 a6, A7 a7, A8 a8) {
			return (*native_function_)(a1_, a2_, a3_, a4_, a5, a6, a7, a8);
		}
	};


	// 引数8個の関数に、5個の引数をbindして、
	// 引数3個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5, typename A6, typename A7, typename A8>
	class NativeFunctionBinder<R(*)(A1, A2, A3, A4, A5, A6, A7, A8), 5> :
		public BaseFunctionHolder<R(*)(A6, A7, A8)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5, A6, A7, A8);
		typedef R (*CallFunctionType)(A6, A7, A8);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef NativeFunctionBinder<FunctionType, 5> ThisType;
	private:
		FunctionType native_function_;
		A1 a1_; A2 a2_; A3 a3_; A4 a4_; A5 a5_;
	public:
  NativeFunctionBinder(FunctionType native_function, A1 a1, A2 a2, A3 a3,
      A4 a4, A5 a5):
		native_function_(native_function),
		a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5)
		{
		}
		virtual ~NativeFunctionBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, native_function_, a1_, a2_, a3_, a4_, a5_);
		}
		virtual R operator() (A6 a6, A7 a7, A8 a8) {
			return (*native_function_)(a1_, a2_, a3_, a4_, a5_, a6, a7, a8);
		}
	};


	// 引数8個の関数に、6個の引数をbindして、
	// 引数2個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5, typename A6, typename A7, typename A8>
	class NativeFunctionBinder<R(*)(A1, A2, A3, A4, A5, A6, A7, A8), 6> :
		public BaseFunctionHolder<R(*)(A7, A8)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5, A6, A7, A8);
		typedef R (*CallFunctionType)(A7, A8);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef NativeFunctionBinder<FunctionType, 6> ThisType;
	private:
		FunctionType native_function_;
		A1 a1_; A2 a2_; A3 a3_; A4 a4_; A5 a5_; A6 a6_;
	public:
  NativeFunctionBinder(FunctionType native_function, A1 a1, A2 a2, A3 a3,
      A4 a4, A5 a5, A6 a6):
		native_function_(native_function),
		a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5), a6_(a6)
		{
		}
		virtual ~NativeFunctionBinder(){
		}
		virtual SuperType * Clone() const {
			return ICK_NEW(ThisType, native_function_, a1_, a2_, a3_, a4_, a5_, a6_);
		}
		virtual R operator() (A7 a7, A8 a8) {
			return (*native_function_)(a1_, a2_, a3_, a4_, a5_, a6_, a7, a8);
		}
	};


	// 引数8個の関数に、7個の引数をbindして、
	// 引数1個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5, typename A6, typename A7, typename A8>
	class NativeFunctionBinder<R(*)(A1, A2, A3, A4, A5, A6, A7, A8), 7> :
		public BaseFunctionHolder<R(*)(A8)>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5, A6, A7, A8);
		typedef R (*CallFunctionType)(A8);
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef NativeFunctionBinder<FunctionType, 7> ThisType;
	private:
		FunctionType native_function_;
		A1 a1_; A2 a2_; A3 a3_; A4 a4_; A5 a5_; A6 a6_; A7 a7_;
	public:
  NativeFunctionBinder(FunctionType native_function, A1 a1, A2 a2, A3 a3,
      A4 a4, A5 a5, A6 a6, A7 a7):
		native_function_(native_function),
		a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5), a6_(a6), a7_(a7)
		{
		}
		virtual ~NativeFunctionBinder(){
		}
		virtual SuperType * Clone() const {
   return ICK_NEW(ThisType, native_function_, a1_, a2_, a3_, a4_, a5_, a6_,
       a7_);
		}
		virtual R operator() (A8 a8) {
			return (*native_function_)(a1_, a2_, a3_, a4_, a5_, a6_, a7_, a8);
		}
	};


	// 引数8個の関数に、8個の引数をbindして、
	// 引数0個の関数にする。
 template <typename R, typename A1, typename A2, typename A3, typename A4,
     typename A5, typename A6, typename A7, typename A8>
	class NativeFunctionBinder<R(*)(A1, A2, A3, A4, A5, A6, A7, A8), 8> :
		public BaseFunctionHolder<R(*)()>{
	public:
		typedef R (*FunctionType)(A1, A2, A3, A4, A5, A6, A7, A8);
		typedef R (*CallFunctionType)();
		typedef BaseFunctionHolder<CallFunctionType> SuperType;
		typedef NativeFunctionBinder<FunctionType, 8> ThisType;
	private:
		FunctionType native_function_;
		A1 a1_; A2 a2_; A3 a3_; A4 a4_; A5 a5_; A6 a6_; A7 a7_; A8 a8_;
	public:
  NativeFunctionBinder(FunctionType native_function, A1 a1, A2 a2, A3 a3,
      A4 a4, A5 a5, A6 a6, A7 a7, A8 a8):
		native_function_(native_function),
		a1_(a1), a2_(a2), a3_(a3), a4_(a4), a5_(a5), a6_(a6), a7_(a7), a8_(a8)
		{
		}
		virtual ~NativeFunctionBinder(){
		}
		virtual SuperType * Clone() const {
   return ICK_NEW(ThisType, native_function_, a1_, a2_, a3_, a4_, a5_, a6_,
       a7_, a8_);
		}
		virtual R operator() () {
			return (*native_function_)(a1_, a2_, a3_, a4_, a5_, a6_, a7_, a8_);
		}
	};


}
